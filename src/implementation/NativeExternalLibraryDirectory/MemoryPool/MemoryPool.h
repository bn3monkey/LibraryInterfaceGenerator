#ifndef __BN3MONKEY_LIBRARYINTERFACEGENERATOR_MemoryPool__
#define __BN3MONKEY_LIBRARYINTERFACEGENERATOR_MemoryPool__
static constexpr char* MemoryPool_header = 
"#ifndef __LIBRARYINTERFACEGENERATOR_MEMORY_POOL__\n"
"#define __LIBRARYINTERFACEGENERATOR_MEMORY_POOL__\n"
"\n"
"#include <cstdint>\n"
"#include <mutex>\n"
"#include \"../Log/Log.hpp\"\n"
"#include <memory>\n"
"#include <functional>\n"
"#include <vector>\n"
"\n"
"class MemoryPool\n"
"{\n"
"public:\n"
"    static bool initialize(size_t _block_num);\n"
"    static void release();\n"
"    static bool isInitialized();\n"
"    static void* alloc(size_t object_size, size_t n);\n"
"    static void dealloc(void* cptr, size_t object_size, size_t n);\n"
"    static void addReleaser(const std::function<void()>& releaser);\n"
"\n"
"\n"
"    template<class T, class... Args>\n"
"    static T* allocate(size_t n, Args... args)\n"
"    {\n"
"       using value_type = T;\n"
"\t\tif (!isInitialized())\n"
"\t\t\treturn nullptr;\n"
"       T* ret = reinterpret_cast<T*>(MemoryPool::alloc(sizeof(T), n));\n"
"       new(ret) T(args...);\n"
"       return ret;\n"
"    }\n"
"    template<class T>\n"
"    static T* allocate(size_t n = 1)\n"
"    {\n"
"        using value_type = T;\n"
"\t\tif (!isInitialized())\n"
"\t\t\treturn nullptr;\n"
"        T* ret = reinterpret_cast<T*>(MemoryPool::alloc(sizeof(T), n));\n"
"        new(ret) T();\n"
"        return ret;\n"
"    }\n"
"    template<class T>\n"
"    static void deallocate(T* ptr, size_t n = 1)\n"
"    {\n"
"\t\tif (!isInitialized())\n"
"\t\t\treturn;\n"
"        using value_type = T;\n"
"        ptr->~T();\n"
"        MemoryPool::dealloc(ptr, sizeof(T), n);\n"
"    }\n"
"\n"
"#ifdef _DEBUG\n"
"    static int8_t* getPool();\n"
"    static int32_t* getDirty();\n"
"    static int8_t* getRearFreedMemoryPtr();\n"
"#endif\n"
"};\n"
"\n"
"template<class T>\n"
"struct MemoryAllocator  /* : public std::allocator<T> */\n"
"{\n"
"    using value_type = T;\n"
"    using pointer = T*;\n"
"    using const_pointer = const T*;\n"
"    using reference = T&;\n"
"    using size_type = std::size_t;\n"
"    using difference_type = std::ptrdiff_t;\n"
"    using propagate_on_container_move_assignment = std::true_type;\n"
"    MemoryAllocator() noexcept {};\n"
"    ~MemoryAllocator() noexcept {};\n"
"    template<class U> MemoryAllocator(const MemoryAllocator<U>& e) noexcept\n"
"    {\n"
"    }\n"
"    pointer allocate(size_type n, const void* hint = 0)\n"
"    {\n"
"        return MemoryPool::allocate<value_type>(n);\n"
"    }\n"
"    void deallocate(pointer ptr, size_type n)\n"
"    {\n"
"        MemoryPool::deallocate<value_type>(ptr, n);\n"
"    }\n"
"    template<typename U>\n"
"    struct rebind {\n"
"        using other =  MemoryAllocator<U>;\n"
"    };\n"
"};\n"
"template <class T, class U>\n"
"constexpr bool operator== (const MemoryAllocator<T>&, const MemoryAllocator<U>&) noexcept\n"
"{\n"
"    return true;\n"
"}\n"
"template <class T, class U>\n"
"constexpr bool operator!= (const MemoryAllocator<T>&, const MemoryAllocator<U>&) noexcept\n"
"{\n"
"    return false;\n"
"}\n"
"\n"
"\n"
"#endif"
"";
static constexpr char* MemoryPool_src = 
"#include \"MemoryPool.hpp\"\n"
"\n"
"static int8_t* pool {nullptr};\n"
"static int32_t* dirty{nullptr};\n"
"\n"
"static int8_t* rear_freed_memory_ptr{nullptr};\n"
"\n"
"static std::mutex mtx;\n"
"size_t block_num;\n"
"size_t dirty_num;\n"
"\n"
"static std::vector<std::function<void()>> releasers;\n"
"\n"
"#ifdef _DEBUG\n"
"int8_t* MemoryPool::getPool()\n"
"{\n"
"    return pool;\n"
"}\n"
"int32_t* MemoryPool::getDirty()\n"
"{\n"
"    return dirty;\n"
"}\n"
"\n"
"int8_t* MemoryPool::getRearFreedMemoryPtr()\n"
"{\n"
"    return rear_freed_memory_ptr;\n"
"}\n"
"#endif\n"
"bool MemoryPool::isInitialized()\n"
"{\n"
"    return pool && dirty;\n"
"}\n"
"bool MemoryPool::initialize(size_t _block_num)\n"
"{\n"
"    std::lock_guard<std::mutex> lock(mtx);\n"
"\n"
"    if (MemoryPool::isInitialized())\n"
"        return true;\n"
"\n"
"    block_num = _block_num;\n"
"    pool = new int8_t[block_num];\n"
"    if (!pool)\n"
"        return false;\n"
"    memset(pool, 0, block_num * sizeof(int8_t));\n"
"\n"
"    dirty_num = block_num / 32 * 4;\n"
"    dirty = new int32_t[dirty_num];\n"
"    if (!dirty)\n"
"    {\n"
"        delete[] pool;\n"
"        pool = nullptr;\n"
"        return false;\n"
"    }\n"
"    memset(dirty, 0, dirty_num * sizeof(int32_t));\n"
"\n"
"    rear_freed_memory_ptr = pool;\n"
"\n"
"    return true;\n"
"}\n"
"void MemoryPool::addReleaser(const std::function<void()>& releaser)\n"
"{\n"
"    releasers.push_back(releaser);\n"
"}\n"
"void MemoryPool::release()\n"
"{\n"
"    std::lock_guard<std::mutex> lock(mtx);\n"
"    if (MemoryPool::isInitialized())\n"
"    {\n"
"        for(auto& releaser : releasers)\n"
"        {\n"
"            releaser();\n"
"        }\n"
"        releasers.clear();\n"
"\n"
"        delete[] pool;\n"
"        pool = nullptr;\n"
"        delete[] dirty;\n"
"        dirty = nullptr;\n"
"\n"
"        rear_freed_memory_ptr = nullptr;\n"
"    }\n"
"}\n"
"\n"
"static inline size_t getRelativeAddress(void* ptr, void* source)\n"
"{\n"
"    return static_cast<size_t>(reinterpret_cast<const char*>(ptr) - reinterpret_cast<const char*>(source));\n"
"}\n"
"\n"
"static void* allocStartedFromMostRearFreedPtr(size_t allocation_size)\n"
"{\n"
"    size_t begin_address = rear_freed_memory_ptr - pool;\n"
"\n"
"    if (begin_address > block_num)\n"
"        return nullptr;\n"
"    \n"
"    size_t end_address = begin_address + allocation_size;\n"
"\n"
"    for (size_t relative_address = begin_address; relative_address < end_address; relative_address++)\n"
"    {\n"
"        size_t dirty_relative_address = (relative_address >> 5); // begin_address /32\n"
"        size_t dirty_bit = relative_address - (dirty_relative_address << 5);  // begin_address %32\n"
"\n"
"        bool is_dirty = *(dirty + dirty_relative_address) & (1 << dirty_bit);\n"
"        if (is_dirty)\n"
"            return nullptr;\n"
"    }\n"
"\n"
"    for (size_t relative_address = begin_address; relative_address < end_address; relative_address++)\n"
"    {\n"
"        size_t dirty_relative_address = (relative_address >> 5); // begin_address /32\n"
"        size_t dirty_bit = relative_address - (dirty_relative_address << 5);  // begin_address %32\n"
"\n"
"        *(dirty + dirty_relative_address) |= (1 << dirty_bit);\n"
"    }\n"
"\n"
"    void* ret = reinterpret_cast<void *>(rear_freed_memory_ptr);\n"
"    rear_freed_memory_ptr = rear_freed_memory_ptr + allocation_size;\n"
"    Log::D(__FUNCTION__, \"Rear address is %p, Relative address is %d\", rear_freed_memory_ptr, getRelativeAddress(rear_freed_memory_ptr, pool));\n"
"    return ret;    \n"
"}\n"
"\n"
"static void* allocStartedFromMostFrontFreedPtr(size_t allocation_size)\n"
"{\n"
"    size_t remained_size = allocation_size;\n"
"\n"
"    size_t begin_address = 0;\n"
"    size_t end_address = rear_freed_memory_ptr - pool;\n"
"    size_t relative_address = 0;\n"
"\n"
"    size_t allocated_start_address = begin_address;\n"
"    \n"
"    for (relative_address = begin_address; \n"
"        relative_address < end_address; \n"
"        relative_address++)\n"
"    {\n"
"        size_t dirty_relative_address = (relative_address >> 5); // relative_address /32\n"
"        size_t dirty_bit = relative_address - (dirty_relative_address << 5);  // relative_address %32\n"
"\n"
"        bool is_dirty = *(dirty + dirty_relative_address) & (1 << dirty_bit);\n"
"        if (is_dirty)\n"
"        {\n"
"            remained_size = allocation_size;\n"
"            allocated_start_address = relative_address;\n"
"        }\n"
"        else\n"
"        {\n"
"            remained_size--;\n"
"            if (!remained_size)\n"
"                break;\n"
"        }\n"
"    }\n"
"    \n"
"    if (relative_address == end_address)\n"
"        return nullptr;\n"
"\n"
"    size_t allocated_end_address = relative_address;\n"
"\n"
"    for (relative_address = allocated_start_address; \n"
"        relative_address < allocated_end_address;\n"
"        relative_address++)\n"
"    {\n"
"        size_t dirty_relative_address = (relative_address >> 5); // relative_address /32\n"
"        size_t dirty_bit = relative_address - (dirty_relative_address << 5);  // relative_address %32\n"
"\n"
"        *(dirty + dirty_relative_address) |= (1 << dirty_bit);\n"
"    }\n"
"\n"
"    void* ret = pool + allocated_start_address;\n"
"    return ret;\n"
"}\n"
"\n"
"\n"
"void* MemoryPool::alloc(size_t object_size, size_t n)\n"
"{\n"
"    std::lock_guard<std::mutex> lock(mtx);\n"
"    if (!MemoryPool::isInitialized())\n"
"        return nullptr;\n"
"\n"
"    size_t allocation_size = object_size * n;\n"
"\n"
"\n"
"    void* ret = allocStartedFromMostRearFreedPtr(allocation_size);\n"
"    if (!ret)\n"
"    {\n"
"        ret = allocStartedFromMostFrontFreedPtr(allocation_size);\n"
"    }\n"
"    Log::D(__FUNCTION__, \"Allocated address is %p, Relative address is %d\", ret, getRelativeAddress(ret, pool));\n"
"    return ret;\n"
"}\n"
"void MemoryPool::dealloc(void* cptr, size_t object_size, size_t n)\n"
"{\n"
"    std::lock_guard<std::mutex> lock(mtx);\n"
"    if (!MemoryPool::isInitialized())\n"
"        return;\n"
"\n"
"\n"
"    if ((int8_t *)cptr < pool && pool + block_num <= (int8_t *)cptr)\n"
"    {\n"
"        return;\n"
"    }\n"
"\n"
"    size_t allocation_size = object_size * n;\n"
"    memset(cptr, 0, object_size * n);\n"
"\n"
"    size_t begin_address = (int8_t *)cptr - pool;\n"
"    size_t end_address = begin_address + object_size * n;\n"
"    size_t relative_address = 0;\n"
"    for (relative_address = begin_address;\n"
"        relative_address < end_address;\n"
"        relative_address++)\n"
"        {\n"
"            size_t dirty_relative_address = (relative_address >> 5); // relative_address /32\n"
"            size_t dirty_bit = relative_address - (dirty_relative_address << 5);  // relative_address %32\n"
"\n"
"            *(dirty + dirty_relative_address) &= ~(1 << dirty_bit);\n"
"        }\n"
"\n"
"\n"
"   \n"
"    {\n"
"        size_t rear_address = rear_freed_memory_ptr - pool - 1;\n"
"        size_t relative_address = rear_address;\n"
"\n"
"        for (;\n"
"            relative_address > 0u;\n"
"            relative_address--)\n"
"        {\n"
"            size_t dirty_relative_address = (relative_address >> 5); // relative_address /32\n"
"            size_t dirty_bit = relative_address - (dirty_relative_address << 5);  // relative_address %32\n"
"\n"
"            bool is_dirty = *(dirty + dirty_relative_address) & (1 << dirty_bit);\n"
"            if (is_dirty)\n"
"                break;\n"
"        }\n"
"\n"
"        if (relative_address == 0)\n"
"        {\n"
"            bool is_dirty = *(dirty) & 1;\n"
"            if (!is_dirty)\n"
"            {\n"
"                rear_freed_memory_ptr = pool;\n"
"                Log::D(__FUNCTION__, \"Rear address is %p, Relative address is %d\", cptr, getRelativeAddress(rear_freed_memory_ptr, pool));\n"
"            }\n"
"        }\n"
"        else\n"
"        {\n"
"            rear_freed_memory_ptr = pool + relative_address + 1;\n"
"            Log::D(__FUNCTION__, \"Rear address is %p, Relative address is %d\", cptr, getRelativeAddress(rear_freed_memory_ptr, pool));\n"
"        }\n"
"    }\n"
"\n"
"    Log::D(__FUNCTION__, \"Released address is %p, Relative address is %d\", cptr, getRelativeAddress(cptr, pool));\n"
"    return;\n"
"}"
"";
#endif // __BN3MONKEY_LIBRARYINTERFACEGENERATOR_MemoryPool__
