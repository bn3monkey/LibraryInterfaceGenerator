#if !defined(__BN3MONKEY_LIBRARY_INTERFACE_GENERATOR_NATIVEINTERFACECONVERTER__)
#define __BN3MONKEY_LIBRARY_INTERFACE_GENERATOR_NATIVEINTERFACECONVERTER__

static constexpr char* nativeInterfaceConverter = 
"#include <memory>\n"
"#include <vector>\n"
"\n"
"template<class T, class ...Args>\n"
"inline void* createReference(Args... args)\n"
"{\n"
"#ifdef __LIBRARYINTERFACEGENERATOR_MEMORY_POOL__\n"
"    auto* ret = MemoryPool::allocate<std::shared_ptr<T>>();\n"
"    ret = std::shared_ptr<T>(MemoryPool::allocate<T>(args), [](T* p) {\n"
"        MemoryPool::deallocate<T>(p);\n"
"    });\n"
"#else\n"
"    auto* ret = new std::shared_ptr<T>(new T(args...));\n"
"#endif\n"
"    return ret;\n"
"}\n"
"template<class T>\n"
"inline void* createReference()\n"
"{\n"
"#ifdef __LIBRARYINTERFACEGENERATOR_MEMORY_POOL__\n"
"    auto* ret = MemoryPool::allocate<std::shared_ptr<T>>();\n"
"    ret = std::shared_ptr<T>(MemoryPool::allocate<T>(), [](T* p) {\n"
"        MemoryPool::deallocate<T>(p);\n"
"    });\n"
"#else\n"
"    auto* ret = new std::shared_ptr<T>();\n"
"#endif\n"
"    return ret;\n"
"}\n"
"template<class T>\n"
"inline void releaseReference(void* cptr)\n"
"{\n"
"#ifdef __LIBRARYINTERFACEGENERATOR_MEMORY_POOL__\n"
"    MemoryPool::deallocate(reinterpret_cast<std::shared_ptr<T>*>(cptr));\n"
"#else\n"
"    delete reinterpret_cast<std::shared_ptr<T>*>(cptr);\n"
"#endif\n"
"}\n"
"template<class T>\n"
"inline std::shared_ptr<T>& getReference(void* cptr)\n"
"{\n"
"    auto* ret = reinterpret_cast<std::shared_ptr<T>*>(cptr);\n"
"    return *ret;\n"
"}\n"
"template<class T>\n"
"inline std::shared_ptr<T>* cloneReference(std::shared_ptr<T>& cptr)\n"
"{\n"
"#ifdef __LIBRARYINTERFACEGENERATOR_MEMORY_POOL__\n"
"    auto* ret = MemoryPool::allocate<std::shared_ptr<T>>();\n"
"    *ret = value;\n"
"#else\n"
"    auto* ret = new shared_ptr<T>(cptr);\n"
"#endif\n"
"    return ret;\n"
"}\n"
"\n"
"\n"
"template<class ENUM>\n"
"inline int32_t createInterfaceEnum(ENUM value)\n"
"{\n"
"\treturn static_cast<int32_t>(value);\n"
"}\n"
"template<class CLASS>\n"
"inline void* createInterfaceObject(std::shared_ptr<CLASS>& value)\n"
"{\n"
"\treturn (void*)cloneReference<T>(value);\n"
"}\n"
"template<class ENUM>\n"
"inline std::vector<int32_t> createInterfaceEnumArray(const std::vector<ENUM>& value)\n"
"{\n"
"\tstd::vector<int32_t> ret;\n"
"\tfor (auto& element : value)\n"
"\t{\n"
"\t\tauto ielement = createInterfaceEnum(element);\n"
"\t\tret.push_back(ielement);\n"
"\t}\n"
"\treturn ret;\n"
"}\n"
"template<class ENUM>\n"
"inline std::vector<int32_t> createInterfaceEnumVector(const std::vector<ENUM>& value)\n"
"{\n"
"\tstd::vector<int32_t> ret;\n"
"\tfor (auto& element : value)\n"
"\t{\n"
"\t\tauto ielement = createInterfaceEnum(element);\n"
"\t\tret.push_back(ielement);\n"
"\t}\n"
"\treturn ret;\n"
"}\n"
"template<class CLASS>\n"
"inline std::vector<void*> createInterfaceObjectArray(const std::vector<CLASS>& value)\n"
"{\n"
"\tstd::vector<void*> ret;\n"
"\tfor (auto& element : value)\n"
"\t{\n"
"\t\tauto* ielement = createInterfaceObject(element);\n"
"\t\tret.push_back(ielement);\n"
"\t}\n"
"\treturn ret;\n"
"}\n"
"template<class CLASS>\n"
"inline std::vector<void*> createInterfaceObjectVector(const std::vector<CLASS>& value)\n"
"{\n"
"\tstd::vector<void*> ret;\n"
"\tfor (auto& element : value)\n"
"\t{\n"
"\t\tauto* ielement = createInterfaceObject(element);\n"
"\t\tret.push_back(ielement);\n"
"\t}\n"
"\treturn ret;\n"
"}\n"
"\n"
"template<class ENUM>\n"
"inline ENUM createNativeEnum(int32_t value)\n"
"{\n"
"\treturn static_cast<ENUM>(value);\n"
"}\n"
"\n"
"template<class CLASS>\n"
"inline std::shared_ptr<CLASS> createNativeObject(const void*& value)\n"
"{\n"
"\treturn getReference<CLASS>((void *)value);\n"
"}\n"
"\n"
"template<class ENUM>\n"
"inline std::vector<ENUM> createNativeEnumArray(const std::vector<int32_t>& value)\n"
"{\n"
"\tstd::vector<ENUM> ret;\n"
"\tfor (auto& element : value)\n"
"\t{\n"
"\t\tauto ielement = convertNativeEnum<ENUM>(element);\n"
"\t\tret.push_back(ielement);\n"
"\t}\n"
"\treturn ret;\n"
"}\n"
"template<class ENUM>\n"
"std::vector<ENUM> createNativeEnumVector(const std::vector<int32_t>& value)\n"
"{\n"
"\tstd::vector<ENUM> ret;\n"
"\tfor (auto& element : value)\n"
"\t{\n"
"\t\tauto ielement = convertNativeEnum<ENUM>(element);\n"
"\t\tret.push_back(ielement);\n"
"\t}\n"
"\treturn ret;\n"
"}\n"
"template<class CLASS>\n"
"std::vector<CLASS> createNativeObjectArray(const std::vector<void *>& value)\n"
"{\n"
"\tstd::vector<CLASS> ret;\n"
"\tfor (auto& element : value)\n"
"\t{\n"
"\t\tauto* ielement = createNativeObject<CLASS>(element);\n"
"\t\tret.push_back(ielement);\n"
"\t}\n"
"}\n"
"template<class CLASS>\n"
"std::vector<std::shared_ptr<CLASS>> createNativeObjectVector(const std::vector<void*>& value)\n"
"{\n"
"\tstd::vector<CLASS> ret;\n"
"\tfor (auto& element : value)\n"
"\t{\n"
"\t\tauto* ielement = createNativeObject<CLASS>(element);\n"
"\t\tret.push_back(ielement);\n"
"\t}\n"
"}\n"
"\n"
"template<class ENUM>\n"
"void copyEnum(const ENUM src, int32_t& dest)\n"
"{\n"
"\tvalue = static_cast<int32_t>(src);\n"
"}\n"
"template<class CLASS>\n"
"void copyObject(const std::shared_ptr<CLASS>& src, void*& dest)\n"
"{\n"
"\tdest = (void*)cloneReference<CLASS>(src);\n"
"}\n"
"\n"
"template<class ENUM>\n"
"void copyEnumArray(const std::vector<ENUM>& src, std::vector<int32_t>& dest)\n"
"{\n"
"\tdest.clear();\n"
"\tfor (auto& element : src)\n"
"\t{\n"
"\t\tauto ielement = createInterfaceEnum(element);\n"
"\t\tdest.push_back(ielement);\n"
"\t}\n"
"}\n"
"\n"
"template<class ENUM>\n"
"void copyEnumVector(const std::vector<ENUM>& src, std::vector<int32_t>& dest)\n"
"{\n"
"\tdest.clear();\n"
"\tfor (auto& element : src)\n"
"\t{\n"
"\t\tauto ielement = createInterfaceEnum(element);\n"
"\t\tdest.push_back(ielement);\n"
"\t}\n"
"}\n"
"\n"
"template<class CLASS>\n"
"inline std::vector<void*> copyObjectArray(const std::vector<CLASS>& src, std::vector<void*>& dest)\n"
"{\n"
"\tdest.clear();\n"
"\tfor (auto& element : value)\n"
"\t{\n"
"\t\tauto* ielement = createInterfaceObject(element);\n"
"\t\tret.push_back(ielement);\n"
"\t}\n"
"\treturn ret;\n"
"}\n"
"template<class CLASS>\n"
"inline std::vector<void*> copyObjectVector(const std::vector<CLASS>& src, std::vector<void*>& dest)\n"
"{\n"
"\tdest.clear();\n"
"\tfor (auto& element : value)\n"
"\t{\n"
"\t\tauto* ielement = createInterfaceObject(element);\n"
"\t\tret.push_back(ielement);\n"
"\t}\n"
"\treturn ret;\n"
"}";

#endif