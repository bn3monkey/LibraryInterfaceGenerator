#if !defined(__BN3MONKEY_LIBRARY_INTERFACE_GENERATOR_MEMORYPOOL_CPP__)
#define __BN3MONKEY_LIBRARY_INTERFACE_GENERATOR_MEMORYPOOL_CPP__
static constexpr char* MEMORYPOOL_CPP = 
"#include \"MemoryPool.hpp\"\n"
"\n"
"static int8_t* pool {nullptr};\n"
"static int32_t* dirty{nullptr};\n"
"\n"
"static int8_t* rear_freed_memory_ptr{nullptr};\n"
"\n"
"static std::mutex mtx;\n"
"size_t block_num;\n"
"size_t dirty_num;\n"
"\n"
"static std::vector<std::function<void()>> releasers;\n"
"\n"
"#ifdef _DEBUG\n"
"int8_t* MemoryPool::getPool()\n"
"{\n"
"    return pool;\n"
"}\n"
"int32_t* MemoryPool::getDirty()\n"
"{\n"
"    return dirty;\n"
"}\n"
"\n"
"int8_t* MemoryPool::getRearFreedMemoryPtr()\n"
"{\n"
"    return rear_freed_memory_ptr;\n"
"}\n"
"#endif\n"
"bool MemoryPool::isInitialized()\n"
"{\n"
"    return pool && dirty;\n"
"}\n"
"bool MemoryPool::initialize(size_t _block_num)\n"
"{\n"
"    std::lock_guard<std::mutex> lock(mtx);\n"
"\n"
"    if (MemoryPool::isInitialized())\n"
"        return true;\n"
"\n"
"    block_num = _block_num;\n"
"    pool = new int8_t[block_num];\n"
"    if (!pool)\n"
"        return false;\n"
"    memset(pool, 0, block_num * sizeof(int8_t));\n"
"\n"
"    dirty_num = block_num / 32 * 4;\n"
"    dirty = new int32_t[dirty_num];\n"
"    if (!dirty)\n"
"    {\n"
"        delete[] pool;\n"
"        pool = nullptr;\n"
"        return false;\n"
"    }\n"
"    memset(dirty, 0, dirty_num * sizeof(int32_t));\n"
"\n"
"    rear_freed_memory_ptr = pool;\n"
"\n"
"    return true;\n"
"}\n"
"void MemoryPool::addReleaser(const std::function<void()>& releaser)\n"
"{\n"
"    releasers.push_back(releaser);\n"
"}\n"
"void MemoryPool::release()\n"
"{\n"
"    std::lock_guard<std::mutex> lock(mtx);\n"
"    if (MemoryPool::isInitialized())\n"
"    {\n"
"        for(auto& releaser : releasers)\n"
"        {\n"
"            releaser();\n"
"        }\n"
"        releasers.clear();\n"
"\n"
"        delete[] pool;\n"
"        pool = nullptr;\n"
"        delete[] dirty;\n"
"        dirty = nullptr;\n"
"\n"
"        rear_freed_memory_ptr = nullptr;\n"
"    }\n"
"}\n"
"\n"
"static inline size_t getRelativeAddress(void* ptr, void* source)\n"
"{\n"
"    return static_cast<size_t>(reinterpret_cast<const char*>(ptr) - reinterpret_cast<const char*>(source));\n"
"}\n"
"\n"
"static void* allocStartedFromMostRearFreedPtr(size_t allocation_size)\n"
"{\n"
"    size_t begin_address = rear_freed_memory_ptr - pool;\n"
"\n"
"    if (begin_address > block_num)\n"
"        return nullptr;\n"
"    \n"
"    size_t end_address = begin_address + allocation_size;\n"
"\n"
"    for (size_t relative_address = begin_address; relative_address < end_address; relative_address++)\n"
"    {\n"
"        size_t dirty_relative_address = (relative_address >> 5); // begin_address /32\n"
"        size_t dirty_bit = relative_address - (dirty_relative_address << 5);  // begin_address %32\n"
"\n"
"        bool is_dirty = *(dirty + dirty_relative_address) & (1 << dirty_bit);\n"
"        if (is_dirty)\n"
"            return nullptr;\n"
"    }\n"
"\n"
"    for (size_t relative_address = begin_address; relative_address < end_address; relative_address++)\n"
"    {\n"
"        size_t dirty_relative_address = (relative_address >> 5); // begin_address /32\n"
"        size_t dirty_bit = relative_address - (dirty_relative_address << 5);  // begin_address %32\n"
"\n"
"        *(dirty + dirty_relative_address) |= (1 << dirty_bit);\n"
"    }\n"
"\n"
"    void* ret = reinterpret_cast<void *>(rear_freed_memory_ptr);\n"
"    rear_freed_memory_ptr = rear_freed_memory_ptr + allocation_size;\n"
"    Log::D(__FUNCTION__, \"Rear address is %p, Relative address is %d\", rear_freed_memory_ptr, getRelativeAddress(rear_freed_memory_ptr, pool));\n"
"    return ret;    \n"
"}\n"
"\n"
"static void* allocStartedFromMostFrontFreedPtr(size_t allocation_size)\n"
"{\n"
"    size_t remained_size = allocation_size;\n"
"\n"
"    size_t begin_address = 0;\n"
"    size_t end_address = rear_freed_memory_ptr - pool;\n"
"    size_t relative_address = 0;\n"
"\n"
"    size_t allocated_start_address = begin_address;\n"
"    \n"
"    for (relative_address = begin_address; \n"
"        relative_address < end_address; \n"
"        relative_address++)\n"
"    {\n"
"        size_t dirty_relative_address = (relative_address >> 5); // relative_address /32\n"
"        size_t dirty_bit = relative_address - (dirty_relative_address << 5);  // relative_address %32\n"
"\n"
"        bool is_dirty = *(dirty + dirty_relative_address) & (1 << dirty_bit);\n"
"        if (is_dirty)\n"
"        {\n"
"            remained_size = allocation_size;\n"
"            allocated_start_address = relative_address;\n"
"        }\n"
"        else\n"
"        {\n"
"            remained_size--;\n"
"            if (!remained_size)\n"
"                break;\n"
"        }\n"
"    }\n"
"    \n"
"    if (relative_address == end_address)\n"
"        return nullptr;\n"
"\n"
"    size_t allocated_end_address = relative_address;\n"
"\n"
"    for (relative_address = allocated_start_address; \n"
"        relative_address < allocated_end_address;\n"
"        relative_address++)\n"
"    {\n"
"        size_t dirty_relative_address = (relative_address >> 5); // relative_address /32\n"
"        size_t dirty_bit = relative_address - (dirty_relative_address << 5);  // relative_address %32\n"
"\n"
"        *(dirty + dirty_relative_address) |= (1 << dirty_bit);\n"
"    }\n"
"\n"
"    void* ret = pool + allocated_start_address;\n"
"    return ret;\n"
"}\n"
"\n"
"\n"
"void* MemoryPool::alloc(size_t object_size, size_t n)\n"
"{\n"
"    std::lock_guard<std::mutex> lock(mtx);\n"
"    if (!MemoryPool::isInitialized())\n"
"        return nullptr;\n"
"\n"
"    size_t allocation_size = object_size * n;\n"
"\n"
"\n"
"    void* ret = allocStartedFromMostRearFreedPtr(allocation_size);\n"
"    if (!ret)\n"
"    {\n"
"        ret = allocStartedFromMostFrontFreedPtr(allocation_size);\n"
"    }\n"
"    Log::D(__FUNCTION__, \"Allocated address is %p, Relative address is %d\", ret, getRelativeAddress(ret, pool));\n"
"    return ret;\n"
"}\n"
"void MemoryPool::dealloc(void* cptr, size_t object_size, size_t n)\n"
"{\n"
"    std::lock_guard<std::mutex> lock(mtx);\n"
"    if (!MemoryPool::isInitialized())\n"
"        return;\n"
"\n"
"\n"
"    if ((int8_t *)cptr < pool && pool + block_num <= (int8_t *)cptr)\n"
"    {\n"
"        return;\n"
"    }\n"
"\n"
"    size_t allocation_size = object_size * n;\n"
"    memset(cptr, 0, object_size * n);\n"
"\n"
"    size_t begin_address = (int8_t *)cptr - pool;\n"
"    size_t end_address = begin_address + object_size * n;\n"
"    size_t relative_address = 0;\n"
"    for (relative_address = begin_address;\n"
"        relative_address < end_address;\n"
"        relative_address++)\n"
"        {\n"
"            size_t dirty_relative_address = (relative_address >> 5); // relative_address /32\n"
"            size_t dirty_bit = relative_address - (dirty_relative_address << 5);  // relative_address %32\n"
"\n"
"            *(dirty + dirty_relative_address) &= ~(1 << dirty_bit);\n"
"        }\n"
"\n"
"\n"
"   \n"
"    {\n"
"        size_t rear_address = rear_freed_memory_ptr - pool - 1;\n"
"        size_t relative_address = rear_address;\n"
"\n"
"        for (;\n"
"            relative_address > 0u;\n"
"            relative_address--)\n"
"        {\n"
"            size_t dirty_relative_address = (relative_address >> 5); // relative_address /32\n"
"            size_t dirty_bit = relative_address - (dirty_relative_address << 5);  // relative_address %32\n"
"\n"
"            bool is_dirty = *(dirty + dirty_relative_address) & (1 << dirty_bit);\n"
"            if (is_dirty)\n"
"                break;\n"
"        }\n"
"\n"
"        if (relative_address == 0)\n"
"        {\n"
"            bool is_dirty = *(dirty) & 1;\n"
"            if (!is_dirty)\n"
"            {\n"
"                rear_freed_memory_ptr = pool;\n"
"                Log::D(__FUNCTION__, \"Rear address is %p, Relative address is %d\", cptr, getRelativeAddress(rear_freed_memory_ptr, pool));\n"
"            }\n"
"        }\n"
"        else\n"
"        {\n"
"            rear_freed_memory_ptr = pool + relative_address + 1;\n"
"            Log::D(__FUNCTION__, \"Rear address is %p, Relative address is %d\", cptr, getRelativeAddress(rear_freed_memory_ptr, pool));\n"
"        }\n"
"    }\n"
"\n"
"    Log::D(__FUNCTION__, \"Released address is %p, Relative address is %d\", cptr, getRelativeAddress(cptr, pool));\n"
"    return;\n"
"}\n";
#endif //__BN3MONKEY_LIBRARY_INTERFACE_GENERATOR_MEMORYPOOL_CPP__
