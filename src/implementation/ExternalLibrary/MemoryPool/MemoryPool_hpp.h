#if !defined(__BN3MONKEY_LIBRARY_INTERFACE_GENERATOR_MEMORYPOOL_HPP__)
#define __BN3MONKEY_LIBRARY_INTERFACE_GENERATOR_MEMORYPOOL_HPP__
static constexpr char* MEMORYPOOL_HPP = 
"#ifndef __LIBRARYINTERFACEGENERATOR_MEMORY_POOL__\n"
"#define __LIBRARYINTERFACEGENERATOR_MEMORY_POOL__\n"
"\n"
"#include <cstdint>\n"
"#include <mutex>\n"
"#include \"../Log/Log.hpp\"\n"
"#include <memory>\n"
"#include <functional>\n"
"#include <vector>\n"
"\n"
"class MemoryPool\n"
"{\n"
"public:\n"
"    static bool initialize(size_t _block_num);\n"
"    static void release();\n"
"    static bool isInitialized();\n"
"    static void* alloc(size_t object_size, size_t n);\n"
"    static void dealloc(void* cptr, size_t object_size, size_t n);\n"
"    static void addReleaser(const std::function<void()>& releaser);\n"
"\n"
"\n"
"    template<class T, class... Args>\n"
"    static T* allocate(size_t n, Args... args)\n"
"    {\n"
"       using value_type = T;\n"
"		if (!isInitialized())\n"
"			return nullptr;\n"
"       T* ret = reinterpret_cast<T*>(MemoryPool::alloc(sizeof(T), n));\n"
"       new(ret) T(args...);\n"
"       return ret;\n"
"    }\n"
"    template<class T>\n"
"    static T* allocate(size_t n = 1)\n"
"    {\n"
"        using value_type = T;\n"
"		if (!isInitialized())\n"
"			return nullptr;\n"
"        T* ret = reinterpret_cast<T*>(MemoryPool::alloc(sizeof(T), n));\n"
"        new(ret) T();\n"
"        return ret;\n"
"    }\n"
"    template<class T>\n"
"    static void deallocate(T* ptr, size_t n = 1)\n"
"    {\n"
"		if (!isInitialized())\n"
"			return;\n"
"        using value_type = T;\n"
"        ptr->~T();\n"
"        MemoryPool::dealloc(ptr, sizeof(T), n);\n"
"    }\n"
"\n"
"#ifdef _DEBUG\n"
"    static int8_t* getPool();\n"
"    static int32_t* getDirty();\n"
"    static int8_t* getRearFreedMemoryPtr();\n"
"#endif\n"
"};\n"
"\n"
"template<class T>\n"
"struct MemoryAllocator  /* : public std::allocator<T> */\n"
"{\n"
"    using value_type = T;\n"
"    using pointer = T*;\n"
"    using const_pointer = const T*;\n"
"    using reference = T&;\n"
"    using size_type = std::size_t;\n"
"    using difference_type = std::ptrdiff_t;\n"
"    using propagate_on_container_move_assignment = std::true_type;\n"
"    MemoryAllocator() noexcept {};\n"
"    ~MemoryAllocator() noexcept {};\n"
"    template<class U> MemoryAllocator(const MemoryAllocator<U>& e) noexcept\n"
"    {\n"
"    }\n"
"    pointer allocate(size_type n, const void* hint = 0)\n"
"    {\n"
"        return MemoryPool::allocate<value_type>(n);\n"
"    }\n"
"    void deallocate(pointer ptr, size_type n)\n"
"    {\n"
"        MemoryPool::deallocate<value_type>(ptr, n);\n"
"    }\n"
"    template<typename U>\n"
"    struct rebind {\n"
"        using other =  MemoryAllocator<U>;\n"
"    };\n"
"};\n"
"template <class T, class U>\n"
"constexpr bool operator== (const MemoryAllocator<T>&, const MemoryAllocator<U>&) noexcept\n"
"{\n"
"    return true;\n"
"}\n"
"template <class T, class U>\n"
"constexpr bool operator!= (const MemoryAllocator<T>&, const MemoryAllocator<U>&) noexcept\n"
"{\n"
"    return false;\n"
"}\n"
"\n"
"\n"
"#endif\n";
#endif //__BN3MONKEY_LIBRARY_INTERFACE_GENERATOR_MEMORYPOOL_HPP__
