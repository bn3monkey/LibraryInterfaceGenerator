#if !defined(__BN3MONKEY_LIBRARY_INTERFACE_GENERATOR_MEMORYPOOL_HPP__)
#define __BN3MONKEY_LIBRARY_INTERFACE_GENERATOR_MEMORYPOOL_HPP__
static constexpr char* MEMORYPOOL_HPP = 
"#ifndef __BN3MONKEY_MEMORY_POOL__\n"
"#define __BN3MONKEY_MEMORY_POOL__\n"
"\n"
"#include <memory>\n"
"#include <list>\n"
"#include <vector>\n"
"#include <deque>\n"
"#include <queue>\n"
"#include <unordered_map>\n"
"#include <string>\n"
"\n"
"#include \"MemoryPoolImpl.hpp\"\n"
"\n"
"#include \"../Tag/Tag.hpp\"\n"
"\n"
"namespace Bn3Monkey\n"
"{\n"
"\tclass Bn3MemoryPool\n"
"\t{\n"
"\tpublic:\n"
"\n"
"        static inline bool initialize(std::initializer_list<size_t> sizes)\n"
"        {\n"
"\t\t\treturn _impl.initialize(sizes);\n"
"        }\n"
"\n"
"\t\tstatic inline void release()\n"
"\t\t{\n"
"\t\t\t_impl.release();\n"
"\t\t}\n"
"\n"
"\t\ttemplate<class Type, class... Args>\n"
"        static inline Type* construct(const Bn3Tag& tag , Args... args)\n"
"\t\t{\n"
"\t\t\treturn _impl.construct<Type>(tag, std::forward<Args>(args)...);\n"
"\t\t}\n"
"\n"
"\n"
"        template<class Type>\n"
"        static inline bool destroy(Type* ptr)\n"
"\t\t{\n"
"\t\t\treturn _impl.destroy<Type>(ptr);\n"
"\t\t}\n"
"\n"
"\t\ttemplate<class Type>\n"
"\t\tstatic inline Type* allocate(const Bn3Tag& tag, size_t size)\n"
"\t\t{\n"
"\t\t\treturn _impl.allocate<Type>(tag, size);\n"
"\t\t}\n"
"\n"
"\n"
"\t\t// In the case of a reference cast to the base class, you must call this method after casting it back to the derived class.\n"
"        template<class Type>\n"
"        static inline bool deallocate(Type* reference, size_t size)\n"
"\t\t{\n"
"\t\t\treturn _impl.deallocate<Type>(reference, size);\n"
"\t\t}\n"
"\n"
"\n"
"\t\tclass Analyzer\n"
"\t\t{\n"
"\t\tpublic:\n"
"\t\t\tstd::string analyzeAll() {\n"
"\t\t\t\treturn _impl.analyzeAll();\n"
"\t\t\t}\n"
"\t\t\t\n"
"\t\t\tstd::string analyzePool(size_t i) {\n"
"\t\t\t\treturn _impl.analyzePool(i);\n"
"\t\t\t}\n"
"\t\t};\n"
"\n"
"\tprivate:\n"
"\t\tstatic Bn3MemoryBlockPools<BLOCK_SIZE_POOL_LENGTH> _impl;\n"
"\t};\n"
"\n"
"\ttemplate<class Type, class... Args>\n"
"\tinline std::shared_ptr<Type> makeSharedFromMemoryPool(const Bn3Tag& tag, Args... args) {\n"
"\t\tauto* raw = Bn3MemoryPool::construct<Type>(tag, std::forward<Args>(args)...);\n"
"\t\tif (!raw)\n"
"\t\t{\n"
"\t\t\treturn nullptr;\n"
"\t\t}\n"
"\t\tauto ret = std::shared_ptr<Type>(raw, [&](Type* ptr) {\n"
"\t\t\tBn3MemoryPool::destroy(ptr);\n"
"\t\t\t});\n"
"\t\treturn ret;\n"
"\t}\n"
"\n"
"\ttemplate<class Type>\n"
"\tclass Bn3Allocator : public std::allocator<Type>\n"
"\t{\n"
"\tpublic:\n"
"\t\tusing value_type = Type;\n"
"\t\tusing pointer = Type*;\n"
"\t\tusing const_pointer = const Type*;\n"
"\t\tusing reference = Type&;\n"
"\t\tusing const_reference = const Type&;\n"
"\t\tusing size_type = size_t;\n"
"\t\tusing difference_type = std::ptrdiff_t;\n"
"\t\tusing propagate_on_container_move_assignment = std::true_type;\n"
"\n"
"\t\tBn3Allocator() = default;\n"
"\t\tBn3Allocator(const Bn3Tag& tag)\n"
"\t\t{\n"
"\t\t\t_tag = tag;\n"
"\t\t}\n"
"\n"
"\t\ttemplate <typename U>\n"
"\t\tBn3Allocator(const Bn3Allocator<U>& other) noexcept : _tag(other._tag) {}\n"
"\n"
"\t\t~Bn3Allocator() noexcept {}\n"
"\n"
"\t\ttemplate <class U>\n"
"\t\tstruct rebind { \n"
"\t\t\tusing other = Bn3Allocator<U> ;\n"
"\t\t};\n"
"\n"
"\t\tpointer allocate(size_type n, const void* hint = 0)\n"
"\t\t{\n"
"\t\t\treturn Bn3MemoryPool::allocate<value_type>(_tag, n);\n"
"\t\t}\n"
"\t\tvoid deallocate(pointer ptr, size_type n) noexcept {\n"
"\t\t\tBn3MemoryPool::deallocate<value_type>(ptr, n);\n"
"\t\t}\n"
"\n"
"\t\ttemplate<class... Args>\n"
"\t\tvoid construct(pointer ptr, Args&&... values)\n"
"\t\t{\n"
"\t\t\tnew (ptr) value_type(std::forward<Args>(values)...);\n"
"\t\t}\n"
"\t\tvoid destroy(pointer ptr)\n"
"\t\t{\n"
"\t\t\tptr->~value_type();\n"
"\t\t}\n"
"\n"
"\t\tBn3Tag _tag;\n"
"\t};\n"
"\n"
"\tclass Bn3Container\n"
"\t{\n"
"\tpublic:\n"
"\t\tusing string = std::basic_string<char, std::char_traits<char>, Bn3Allocator<char>>;\n"
"\n"
"\t\ttemplate<class Type>\n"
"\t\tusing list = std::list<Type, Bn3Allocator<Type>>;\n"
"\n"
"\t\ttemplate<class Type>\n"
"\t\tusing deque = std::deque<Type, Bn3Allocator<Type>>;\n"
"\n"
"\t\ttemplate<class Type>\n"
"\t\tusing vector = std::vector<Type, Bn3Allocator<Type>>;\n"
"\n"
"\t\ttemplate<class Type>\n"
"\t\tusing queue = std::queue<Type, std::deque<Type, Bn3Allocator<Type>>>;\n"
"\n"
"\t\ttemplate<class Key, class Value>\n"
"\t\tusing map = std::unordered_map<Key, Value, std::hash<Key>, std::equal_to<Key>, Bn3Allocator<std::pair<const Key, Value>>>;\n"
"\t};\n"
"\n"
"}\n"
"\n"
"#endif\n";
#endif //__BN3MONKEY_LIBRARY_INTERFACE_GENERATOR_MEMORYPOOL_HPP__
