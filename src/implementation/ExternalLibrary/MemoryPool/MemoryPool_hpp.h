#if !defined(__BN3MONKEY_LIBRARY_INTERFACE_GENERATOR_MEMORYPOOL_HPP__)
#define __BN3MONKEY_LIBRARY_INTERFACE_GENERATOR_MEMORYPOOL_HPP__
static constexpr char* MEMORYPOOL_HPP = 
"#ifndef __BN3MONKEY_MEMORY_POOL__\n"
"#define __BN3MONKEY_MEMORY_POOL__\n"
"\n"
"#include <memory>\n"
"#include <list>\n"
"#include <vector>\n"
"#include <deque>\n"
"#include <queue>\n"
"#include <unordered_map>\n"
"#include <string>\n"
"\n"
"#include \"MemoryPoolImpl.hpp\"\n"
"\n"
"#include \"Tag.hpp\"\n"
"\n"
"namespace Bn3Monkey\n"
"{\n"
"	class Bn3MemoryPool\n"
"	{\n"
"	public:\n"
"\n"
"        static inline bool initialize(std::initializer_list<size_t> sizes)\n"
"        {\n"
"			return _impl.initialize(sizes);\n"
"        }\n"
"\n"
"		static inline void release()\n"
"		{\n"
"			_impl.release();\n"
"		}\n"
"\n"
"		template<class Type, class... Args>\n"
"        static inline Type* construct(const Bn3Tag& tag , Args... args)\n"
"		{\n"
"			return _impl.construct<Type>(tag, std::forward<Args>(args)...);\n"
"		}\n"
"\n"
"\n"
"        template<class Type>\n"
"        static inline bool destroy(Type* ptr)\n"
"		{\n"
"			return _impl.destroy<Type>(ptr);\n"
"		}\n"
"\n"
"		template<class Type>\n"
"		static inline Type* allocate(const Bn3Tag& tag, size_t size)\n"
"		{\n"
"			return _impl.allocate<Type>(tag, size);\n"
"		}\n"
"\n"
"\n"
"		// In the case of a reference cast to the base class, you must call this method after casting it back to the derived class.\n"
"        template<class Type>\n"
"        static inline bool deallocate(Type* reference, size_t size)\n"
"		{\n"
"			return _impl.deallocate<Type>(reference, size);\n"
"		}\n"
"\n"
"		class Analyzer\n"
"		{\n"
"		public:\n"
"			std::string analyzeAll() {\n"
"				return _impl.analyzeAll();\n"
"			}\n"
"			\n"
"			std::string analyzePool(size_t i) {\n"
"				return _impl.analyzePool(i);\n"
"			}\n"
"		};\n"
"\n"
"	private:\n"
"		static Bn3MemoryBlockPools<BLOCK_SIZE_POOL_LENGTH> _impl;\n"
"	};\n"
"\n"
"	template<class Type, class... Args>\n"
"	inline std::shared_ptr<Type> makeSharedFromMemoryPool(const Bn3Tag& tag, Args... args) {\n"
"		auto* raw = Bn3MemoryPool::construct<Type>(tag, std::forward<Args>(args)...);\n"
"		if (!raw)\n"
"		{\n"
"			return nullptr;\n"
"		}\n"
"		auto ret = std::shared_ptr<Type>(raw, [&](Type* ptr) {\n"
"			Bn3MemoryPool::destroy(ptr);\n"
"			});\n"
"		return ret;\n"
"	}\n"
"\n"
"	template<class Type>\n"
"	class Bn3Allocator : public std::allocator<Type>\n"
"	{\n"
"	public:\n"
"		using value_type = Type;\n"
"		using pointer = Type*;\n"
"		using const_pointer = const Type*;\n"
"		using reference = Type&;\n"
"		using const_reference = const Type&;\n"
"		using size_type = size_t;\n"
"		using difference_type = std::ptrdiff_t;\n"
"		using propagate_on_container_move_assignment = std::true_type;\n"
"\n"
"		Bn3Allocator() = default;\n"
"		Bn3Allocator(const Bn3Tag& tag)\n"
"		{\n"
"			_tag = tag;\n"
"		}\n"
"\n"
"		template <typename U>\n"
"		Bn3Allocator(const Bn3Allocator<U>& other) noexcept : _tag(other._tag) {}\n"
"\n"
"		~Bn3Allocator() noexcept {}\n"
"\n"
"		template <class U>\n"
"		struct rebind { \n"
"			using other = Bn3Allocator<U> ;\n"
"		};\n"
"\n"
"		pointer allocate(size_type n, const void* hint = 0)\n"
"		{\n"
"			return Bn3MemoryPool::allocate<value_type>(_tag, n);\n"
"		}\n"
"		void deallocate(pointer ptr, size_type n) noexcept {\n"
"			Bn3MemoryPool::deallocate<value_type>(ptr, n);\n"
"		}\n"
"\n"
"		template<class... Args>\n"
"		void construct(pointer ptr, Args&&... values)\n"
"		{\n"
"			new (ptr) value_type(std::forward<Args>(values)...);\n"
"		}\n"
"		void destroy(pointer ptr)\n"
"		{\n"
"			ptr->~value_type();\n"
"		}\n"
"\n"
"		Bn3Tag _tag;\n"
"	};\n"
"\n"
"	class Bn3Container\n"
"	{\n"
"	public:\n"
"		using string = std::basic_string<char, std::char_traits<char>, Bn3Allocator<char>>;\n"
"\n"
"		template<class Type>\n"
"		using list = std::list<Type, Bn3Allocator<Type>>;\n"
"\n"
"		template<class Type>\n"
"		using deque = std::deque<Type, Bn3Allocator<Type>>;\n"
"\n"
"		template<class Type>\n"
"		using vector = std::vector<Type, Bn3Allocator<Type>>;\n"
"\n"
"		template<class Type>\n"
"		using queue = std::queue<Type, std::deque<Type, Bn3Allocator<Type>>>;\n"
"\n"
"		template<class Key, class Value>\n"
"		using map = std::unordered_map<Key, Value, std::hash<Key>, std::equal_to<Key>, Bn3Allocator<std::pair<const Key, Value>>>;\n"
"	};\n"
"\n"
"}\n"
"\n"
"#endif\n";
#endif //__BN3MONKEY_LIBRARY_INTERFACE_GENERATOR_MEMORYPOOL_HPP__
