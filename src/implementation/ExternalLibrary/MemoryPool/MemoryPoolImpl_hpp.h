#if !defined(__BN3MONKEY_LIBRARY_INTERFACE_GENERATOR_MEMORYPOOLIMPL_HPP__)
#define __BN3MONKEY_LIBRARY_INTERFACE_GENERATOR_MEMORYPOOLIMPL_HPP__
static constexpr char* MEMORYPOOLIMPL_HPP = 
"#ifndef __BN3MONKEY_MEMORY_POOL_IMPL__\n"
"#define __BN3MONKEY_MEMORY_POOL_IMPL__\n"
"\n"
"#include <mutex>\n"
"#include <vector>\n"
"#include <functional>\n"
"\n"
"#include <string>\n"
"#include <sstream>\n"
"\n"
"#include \"Tag.hpp\"\n"
"#include \"../Log/Log.hpp\"\n"
"\n"
"#ifdef BN3MONKEY_DEBUG\n"
"#define FOR_DEBUG(t) t\n"
"#else \n"
"#define FOR_DEBUG(t)\n"
"#endif\n"
"\n"
"#ifdef __BN3MONKEY_LOG__\n"
"#ifdef BN3MONKEY_DEBUG\n"
"#define LOG_D(text, ...) Bn3Monkey::Log::D(__FUNCTION__, text, __VA_ARGS__)\n"
"#else\n"
"#define LOG_D(text, ...)\n"
"#endif\n"
"#define LOG_V(text, ...) Bn3Monkey::Log::V(__FUNCTION__, text, __VA_ARGS__)\n"
"#define LOG_E(text, ...) Bn3Monkey::Log::E(__FUNCTION__, text, __VA_ARGS__)\n"
"#else\n"
"#define LOG_D(text, ...)    \n"
"#define LOG_V(text, ...) \n"
"#define LOG_E(text, ...)\n"
"#endif\n"
"\n"
"\n"
"namespace Bn3Monkey\n"
"{\n"
"    \n"
"    constexpr size_t BLOCK_SIZE_POOL[] = { 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 0};\n"
"    constexpr size_t BLOCK_SIZE_POOL_LENGTH = sizeof(BLOCK_SIZE_POOL) / sizeof(size_t) - 1;\n"
"    constexpr size_t MAX_BLOCK_SIZE = BLOCK_SIZE_POOL[BLOCK_SIZE_POOL_LENGTH - 1];\n"
"    constexpr size_t HEADER_SIZE = sizeof(unsigned int) + sizeof(int) + sizeof(void*) + sizeof(Bn3Tag);\n"
"\n"
"    template<size_t BlockSize>\n"
"    struct Bn3MemoryBlock\n"
"    {\n"
"        constexpr static unsigned int MAGIC_NUMBER = 0xFEDCBA98;\n"
"        struct Bn3MemoryHeader\n"
"        {\n"
"            const unsigned int dirty = 0xFEDCBA98;\n"
"            Bn3Tag tag;\n"
"            int is_allocated{ false };\n"
"            Bn3MemoryBlock<BlockSize>* freed_ptr{nullptr};\n"
"        };\n"
"\n"
"        static_assert(HEADER_SIZE == sizeof(Bn3MemoryHeader));\n"
"\n"
"        constexpr static size_t size = BlockSize;\n"
"        constexpr static size_t header_size = sizeof(Bn3MemoryHeader);\n"
"        constexpr static size_t content_size = BlockSize - header_size;\n"
"\n"
"        Bn3MemoryHeader header;\n"
"        char content[content_size]{ 0 };\n"
"\n"
"        static Bn3MemoryBlock<BlockSize>* getBlockReference(void* ptr)\n"
"        {\n"
"            if ((void *)nullptr <= ptr && ptr < (void*)header_size)\n"
"            {\n"
"                LOG_E(\"reference is nullptr (%p)\", ptr);\n"
"                return nullptr;\n"
"            }\n"
"\n"
"            auto* content_ptr = reinterpret_cast<char*>(ptr);\n"
"            auto* block_ptr = content_ptr - header_size;\n"
"            auto* block_casted_ptr = reinterpret_cast<Bn3MemoryBlock<BlockSize>*>(block_ptr);\n"
"            if (block_casted_ptr->header.dirty != MAGIC_NUMBER)\n"
"            {\n"
"                LOG_E(\"Reference (%p) cannot be transformed as memory block.\", block_casted_ptr);\n"
"                LOG_E(\"Reference is not allocated by memory pool or memory header is corrupted\");\n"
"                return nullptr;\n"
"            }\n"
"            return block_casted_ptr;\n"
"        }\n"
"    };\n"
"\n"
"\n"
"    class Bn3BlockHelper\n"
"    {    \n"
"    public:\n"
"        Bn3BlockHelper(size_t object_size)\n"
"        {\n"
"            _idx = Finder<0>::find(object_size);\n"
"            _size = BLOCK_SIZE_POOL[_idx];\n"
"            _content_size = _size - HEADER_SIZE;\n"
"        }\n"
"\n"
"        inline size_t idx() { return _idx; }\n"
"        inline size_t size() { return _size; }\n"
"        inline size_t content_size() { return _content_size; }\n"
"\n"
"    private:\n"
"        template<size_t idx>\n"
"        class Finder\n"
"        {\n"
"        public:\n"
"            constexpr static size_t find(size_t object_size) {\n"
"                return object_size <= Bn3MemoryBlock< BLOCK_SIZE_POOL[idx]>::content_size ?\n"
"                    idx :\n"
"                    Finder<idx + 1>::find(object_size);\n"
"            }\n"
"\n"
"        };\n"
"\n"
"        template<>\n"
"        class Finder<BLOCK_SIZE_POOL_LENGTH>\n"
"        {\n"
"        public:\n"
"            constexpr static size_t find(size_t object_size) {\n"
"                return BLOCK_SIZE_POOL_LENGTH;\n"
"            }\n"
"        };\n"
"\n"
"        size_t _idx;\n"
"        size_t _size;\n"
"        size_t _content_size;\n"
"    };\n"
"\n"
"\n"
"    class Bn3MemoryBlockPool\n"
"    {\n"
"    public:\n"
"        virtual bool initialize(size_t size) = 0;\n"
"        virtual void release() = 0;\n"
"        virtual std::string analyze() = 0;\n"
"\n"
"        virtual void* allocate(const Bn3Tag& tag) = 0;\n"
"        virtual bool deallocate(void* ptr) = 0;\n"
"    \n"
"    protected:\n"
"        size_t max_allocated{ 0 };\n"
"        size_t current_allocated{ 0 };\n"
"        std::mutex mutex;\n"
"    };\n"
"\n"
"    template<size_t idx>\n"
"    class Bn3MemoryBlockIndexedPool : public Bn3MemoryBlockPool\n"
"    {\n"
"    public:\n"
"        bool initialize(size_t size) override\n"
"        {\n"
"            LOG_D(\"Memory block pool (idx : %d / block size : %d) initialize with a size of %d\", idx, block_size, size);\n"
"            blocks.resize(size);\n"
"\n"
"            front = &blocks.front();\n"
"            back = &blocks.back();\n"
"\n"
"            freed_ptr = front;\n"
"            for (auto* block_ptr = front; block_ptr < back; block_ptr += 1)\n"
"            {\n"
"                block_ptr->header.freed_ptr = block_ptr + 1;\n"
"            }\n"
"            back->header.freed_ptr = nullptr;\n"
"\n"
"            return true;\n"
"        }\n"
"\n"
"        void release() override {\n"
"            blocks.clear();\n"
"            freed_ptr = nullptr;\n"
"            front = nullptr;\n"
"            back = nullptr;\n"
"        }\n"
"\n"
"        std::string analyze() override\n"
"        {\n"
"            std::stringstream ss;\n"
"            ss << \"- Memory Block Pool (\" << idx << \" / \" << block_size << \") - \n\";\n"
"            ss << \"    Max allocated : \" << max_allocated << \"\n\n\";\n"
"\n"
"            size_t start_idx = freed_ptr - front;\n"
"\n"
"            for (size_t i = 0; i < blocks.size(); i++)\n"
"            {\n"
"                auto& block = blocks[i];\n"
"                auto& is_allocated = block.header.is_allocated;\n"
"                auto tag = block.header.tag.str();\n"
"\n"
"                if (start_idx == i)\n"
"                    ss << \"S\";\n"
"                else\n"
"                    ss << \" \";\n"
"                ss << \"   (\" << i << \") : \" << (is_allocated ? \"O\" : \"X\") << \" [\" << tag << \"] \";\n"
"\n"
"                auto freed_ptr = block.header.freed_ptr;\n"
"                if (freed_ptr == nullptr)\n"
"                    ss << \" -> null\n\";\n"
"                else\n"
"                {\n"
"                    auto next_i = freed_ptr - front;\n"
"                    ss << \" -> \" << next_i << \"\n\";\n"
"                }\n"
"            }\n"
"            ss << \"\n\";\n"
"            return ss.str();\n"
"        }\n"
"\n"
"        void* allocate(const Bn3Tag& tag) override\n"
"        {\n"
"            Bn3MemoryBlock<block_size>* ret{ nullptr };\n"
"            {\n"
"                std::lock_guard<std::mutex> lock(mutex);\n"
"\n"
"\n"
"                if (freed_ptr == nullptr)\n"
"                {\n"
"                    LOG_E(\"The capacity of memory block pool (idx : %d / block size : %d) has been exceeded\", idx, block_size);\n"
"                    return nullptr;\n"
"                }\n"
"\n"
"                current_allocated += 1;\n"
"                if (current_allocated > max_allocated)\n"
"                    max_allocated = current_allocated;\n"
"\n"
"\n"
"                ret = freed_ptr;\n"
"                auto* next_freed_ptr = freed_ptr->header.freed_ptr;\n"
"                freed_ptr->header.freed_ptr = nullptr;\n"
"                freed_ptr = next_freed_ptr;\n"
"\n"
"                ret->header.is_allocated = true;\n"
"                ret->header.tag = tag;\n"
"            }\n"
"\n"
"            auto* ptr = ret->content;\n"
"            LOG_D(\"Memory block pool (idx : %d / block size : %d) allocates %d\", idx, block_size, ret - front);\n"
"            return ptr;\n"
"        }\n"
"\n"
"        bool deallocate(void* ptr) override\n"
"        {\n"
"            auto* block_ptr = Bn3MemoryBlock<block_size>::getBlockReference(ptr);\n"
"            if (block_ptr < front || back < block_ptr)\n"
"            {\n"
"                LOG_E(\"This reference (%p) is not from memory block pool (idx : %d / block size : %d)\", ptr, idx, block_size);\n"
"                return false;\n"
"            }\n"
"            {\n"
"                std::lock_guard<std::mutex> lock(mutex);\n"
"                if (block_ptr->header.is_allocated == false)\n"
"                {\n"
"                    LOG_E(\"This reference (%d) is already deallocated\", block_ptr - front);\n"
"                    return false;\n"
"                }\n"
"\n"
"                current_allocated -= 1;\n"
"\n"
"                block_ptr->header.is_allocated = false;\n"
"                block_ptr->header.tag.clear();\n"
"\n"
"                block_ptr->header.freed_ptr = freed_ptr;\n"
"                freed_ptr = block_ptr;\n"
"\n"
"            }\n"
"\n"
"            LOG_D(\"Memory block pool (idx : %d / block size : %d) deallocates %d\", idx, block_size, block_ptr - front);\n"
"            return true;\n"
"        }\n"
"\n"
"    private:\n"
"        constexpr static size_t block_size = BLOCK_SIZE_POOL[idx];\n"
"\n"
"        std::vector<Bn3MemoryBlock<block_size>> blocks;\n"
"        Bn3MemoryBlock<block_size>* freed_ptr;\n"
"\n"
"        Bn3MemoryBlock<block_size>* front;\n"
"        Bn3MemoryBlock<block_size>* back;\n"
"    };\n"
"\n"
"\n"
"    template<size_t pool_length>\n"
"    class Bn3MemoryBlockPools\n"
"    {\n"
"    public:\n"
"        static_assert(pool_length <= BLOCK_SIZE_POOL_LENGTH, \"Static Memory Block Pools Size is invalid\");\n"
"        constexpr static size_t max_pool_num = pool_length - 1;\n"
"\n"
"        Bn3MemoryBlockPools()\n"
"        {\n"
"            initializePool<max_pool_num>(_pools, _pool_storage, sizeof(_pool_storage));\n"
"        }\n"
"\n"
"        bool initialize(std::initializer_list<size_t> sizes)\n"
"        {\n"
"            LOG_D(\"Memory Block Pools Initialize\");\n"
"            size_t idx = 0;\n"
"            for (auto& size : sizes)\n"
"            {\n"
"                if (!_pools[idx++]->initialize(size))\n"
"                    return false;\n"
"            }\n"
"            return true;\n"
"        }\n"
"        void release()\n"
"        {\n"
"            LOG_D(\"Memory Block Pools release\");\n"
"            for (auto* pool : _pools)\n"
"            {\n"
"                pool->release();\n"
"            }\n"
"        }\n"
"\n"
"        template<class Type, class... Args>\n"
"        Type* construct(const Bn3Tag& tag, Args... args)\n"
"        {\n"
"            constexpr size_t object_size = sizeof(Type);\n"
"            size_t idx = Bn3BlockHelper(object_size).idx();\n"
"            Type* ret = nullptr;\n"
"\n"
"            if (idx >= pool_length)\n"
"            {\n"
"                ret = new Type(std::forward<Args>(args)...);\n"
"                return ret;\n"
"            }\n"
"            auto* ptr = _pools[idx]->allocate(tag);\n"
"            if (!ptr)\n"
"            {\n"
"                LOG_E(\"The capcatiy of memory block pool has been exceeded\");\n"
"                return nullptr;\n"
"            }\n"
"            ret = new (ptr) Type(std::forward<Args>(args)...);\n"
"            return ret;\n"
"        }\n"
"\n"
"        template<class Type>\n"
"        bool destroy(Type* reference)\n"
"        {\n"
"            constexpr size_t object_size = sizeof(Type);\n"
"            size_t idx = Bn3BlockHelper(object_size).idx();\n"
"            if (idx >= pool_length)\n"
"            {\n"
"                delete reference;\n"
"                return true;\n"
"            }\n"
"\n"
"            if (reference)\n"
"                reference->~Type();\n"
"            return _pools[idx]->deallocate(reference);\n"
"        }\n"
"\n"
"        template<class Type>\n"
"        Type* allocate(const Bn3Tag& tag, size_t size)\n"
"        {\n"
"            constexpr size_t object_size = sizeof(Type);\n"
"            size_t allocated_size = sizeof(Type) * size;\n"
"            size_t idx = Bn3BlockHelper(allocated_size).idx();\n"
"            if (idx >= pool_length)\n"
"            {\n"
"                auto* ptr =  new char[allocated_size];\n"
"                Type* ret = reinterpret_cast<Type*>(ptr);\n"
"                return ret;\n"
"            }\n"
"\n"
"            auto* ptr = _pools[idx]->allocate(tag);\n"
"            if (!ptr)\n"
"            {\n"
"                LOG_E(\"The capcatiy of memory block pool has been exceeded\");\n"
"                return nullptr;\n"
"            }\n"
"            Type* ret = reinterpret_cast<Type*>(ptr);\n"
"            return ret;\n"
"        }\n"
"\n"
"\n"
"        template<class Type>\n"
"        bool deallocate(Type* reference, size_t size)\n"
"        {\n"
"            constexpr size_t object_size = sizeof(Type);\n"
"            size_t allocated_size = sizeof(Type) * size;\n"
"            size_t idx = Bn3BlockHelper(allocated_size).idx();\n"
"            if (idx >= pool_length)\n"
"            {\n"
"                delete[] (char *)reference;\n"
"                return true;\n"
"            }\n"
"\n"
"            bool ret = _pools[idx]->deallocate(reference);\n"
"            return ret;\n"
"        }\n"
"\n"
"\n"
"\n"
"        std::string analyzeAll()\n"
"        {\n"
"            std::stringstream ss;\n"
"            for (auto* pool : _pools)\n"
"            {\n"
"                ss << pool->analyze();\n"
"            }\n"
"            return ss.str();\n"
"        }\n"
"        \n"
"        std::string analyzePool(size_t idx)\n"
"        {\n"
"            return _pools[idx]->analyze();\n"
"        }\n"
"\n"
"    private:\n"
"                \n"
"\n"
"        template<size_t idx>\n"
"        constexpr static size_t getStorageSize()\n"
"        {\n"
"            return sizeof(Bn3MemoryBlockIndexedPool<idx-1>) + getStorageSize<idx - 1>();\n"
"        }\n"
"        template<>\n"
"        constexpr static size_t getStorageSize<1>()\n"
"        {\n"
"            return sizeof(Bn3MemoryBlockIndexedPool<0>);\n"
"        }\n"
"        template<size_t idx>\n"
"        constexpr static void initializePool(Bn3MemoryBlockPool* (&pool)[pool_length], char* storage, size_t offset)\n"
"        {\n"
"            using IndexedPool = Bn3MemoryBlockIndexedPool<idx>;\n"
"            size_t pool_size = sizeof(IndexedPool);\n"
"            auto* ptr = new (storage + offset - pool_size) IndexedPool();\n"
"            pool[idx] = ptr;\n"
"\n"
"            initializePool<idx - 1>(pool, storage, offset - pool_size);\n"
"        }\n"
"        template<>\n"
"        constexpr static void initializePool<0>(Bn3MemoryBlockPool* (&pool)[pool_length], char* storage, size_t offset)\n"
"        {\n"
"            using IndexedPool = Bn3MemoryBlockIndexedPool<0>;\n"
"            size_t pool_size = sizeof(IndexedPool);\n"
"            assert(offset - pool_size == 0);\n"
"            auto* ptr = new (storage + offset - pool_size) IndexedPool();\n"
"            pool[0] = ptr;\n"
"        }\n"
"\n"
"        Bn3MemoryBlockPool* _pools[pool_length];\n"
"        char _pool_storage[getStorageSize<pool_length>()];\n"
"    };\n"
"}\n"
"\n"
"#endif\n";
#endif //__BN3MONKEY_LIBRARY_INTERFACE_GENERATOR_MEMORYPOOLIMPL_HPP__
