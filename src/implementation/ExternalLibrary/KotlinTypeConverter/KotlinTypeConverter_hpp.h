#if !defined(__BN3MONKEY_LIBRARY_INTERFACE_GENERATOR_KOTLINTYPECONVERTER_HPP__)
#define __BN3MONKEY_LIBRARY_INTERFACE_GENERATOR_KOTLINTYPECONVERTER_HPP__
static constexpr char* KOTLINTYPECONVERTER_HPP = 
"#ifndef __BN3MONKEY_KOTLIN_TYPE_CONVERTER__\n"
"#define __BN3MONKEY_KOTLIN_TYPE_CONVERTER__\n"
"\n"
"#include <jni.h>\n"
"#include <vector>\n"
"#include <functional>\n"
"#include <algorithm>\n"
"#include <cstdio>\n"
"#include <cassert>\n"
"#include <string>\n"
"#include <array>\n"
"\n"
"#include \"../Log/Log.hpp\"\n"
"\n"
"namespace Bn3Monkey\n"
"{\n"
"    namespace Kotlin\n"
"    {\n"
"        class KotlinTypeConverter {\n"
"        public:\n"
"            static bool initialize(JNIEnv* env);\n"
"            static void release(JNIEnv* env);\n"
"            virtual const char* signature() = 0;\n"
"\n"
"            struct Helper {\n"
"                jclass _KBoolean;\n"
"                jclass _KByte;\n"
"                jclass _KShort;\n"
"                jclass _KInt;\n"
"                jclass _KLong;\n"
"                jclass _KFloat;\n"
"                jclass _KDouble;\n"
"                jclass _KString;\n"
"                jclass _KVector; // arraylist\n"
"\n"
"                jmethodID _KBoolean_init;\n"
"                jmethodID _KBoolean_booleanValue;\n"
"\n"
"                jmethodID _KByte_init;\n"
"                jmethodID _KByte_byteValue;\n"
"\n"
"                jmethodID _KShort_init;\n"
"                jmethodID _KShort_shortValue;\n"
"\n"
"                jmethodID _KInt_init;\n"
"                jmethodID _KInt_intValue;\n"
"\n"
"                jmethodID _KLong_init;\n"
"                jmethodID _KLong_longValue;\n"
"\n"
"                jmethodID _KFloat_init;\n"
"                jmethodID _KFloat_floatValue;\n"
"\n"
"                jmethodID _KDouble_init;\n"
"                jmethodID _KDouble_doubleValue;\n"
"\n"
"                jmethodID _KVector_init;\n"
"                jmethodID _KVector_size;\n"
"                jmethodID _KVector_add;\n"
"                jmethodID _KVector_get;\n"
"                jmethodID _KVector_clear;\n"
"            };\n"
"            \n"
"        protected:\n"
"            static bool isInitialized;\n"
"            static JavaVM* jvm;\n"
"\n"
"\n"
"            static Helper helper;\n"
"        };\n"
"\n"
"        class KVoid : public KotlinTypeConverter\n"
"        {\n"
"        public:\n"
"            using ManagedType = void;\n"
"            using KotlinType = void;\n"
"            using KotlinWrapperType = void;\n"
"            const char* signature() override { return \"V\"; }\n"
"        };\n"
"\n"
"        class KBoolean : public KotlinTypeConverter\n"
"        {\n"
"        public:\n"
"            const char* signature() override { return \"Z\"; }\n"
"\n"
"            using ManagedType = bool;\n"
"            using KotlinType = jboolean;\n"
"            using KotlinWrapperType = jobject;\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<ManagedType>(value);\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return env->CallBooleanMethod(value, helper._KBoolean_booleanValue);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return env->NewObject(helper._KBoolean, helper._KBoolean_init, value);\n"
"            }\n"
"        private:    \n"
"        };\n"
"        class KInt8 : public KotlinTypeConverter\n"
"        {\n"
"        public:\n"
"            const char* signature() override { return \"B\"; }\n"
"\n"
"            using ManagedType = int8_t;\n"
"            using KotlinType = jbyte;\n"
"            using KotlinWrapperType = jobject;\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<ManagedType>(value);\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return env->CallByteMethod(value, helper._KByte_byteValue);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return env->NewObject(helper._KByte, helper._KByte_init, value);\n"
"            }\n"
"        };\n"
"        class KInt16 : public KotlinTypeConverter\n"
"        {\n"
"        public:\n"
"            const char* signature() override { return \"S\"; }\n"
"\n"
"            using ManagedType = int16_t;\n"
"            using KotlinType = jshort;\n"
"            using KotlinWrapperType = jobject;\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<ManagedType>(value);\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return env->CallShortMethod(value, helper._KShort_shortValue);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return env->NewObject(helper._KShort, helper._KShort_init, value);\n"
"            }\n"
"        };\n"
"        class KInt32 : public KotlinTypeConverter\n"
"        {\n"
"        public:\n"
"            const char* signature() override { return \"I\"; }\n"
"\n"
"            using ManagedType = int32_t;\n"
"            using KotlinType = jint;\n"
"            using KotlinWrapperType = jobject;\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<ManagedType>(value);\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return env->CallIntMethod(value, helper._KInt_intValue);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return env->NewObject(helper._KInt, helper._KInt_init, value);\n"
"            }\n"
"        };\n"
"        class KInt64 : public KotlinTypeConverter\n"
"        {\n"
"        public:\n"
"            const char* signature() override { return \"J\"; }\n"
"\n"
"            using ManagedType = int64_t;\n"
"            using KotlinType = jlong;\n"
"            using KotlinWrapperType = jobject;\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<ManagedType>(value);\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return env->CallLongMethod(value, helper._KLong_longValue);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return env->NewObject(helper._KLong, helper._KLong_init, value);\n"
"            }\n"
"        };\n"
"        class KFloat : public KotlinTypeConverter\n"
"        {\n"
"        public:\n"
"            const char* signature() override { return \"F\"; }\n"
"\n"
"            using ManagedType = float;\n"
"            using KotlinType = jfloat;\n"
"            using KotlinWrapperType = jobject;\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<ManagedType>(value);\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return env->CallFloatMethod(value, helper._KFloat_floatValue);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return env->NewObject(helper._KFloat, helper._KFloat_init, value);\n"
"            }\n"
"        };\n"
"        class KDouble : public KotlinTypeConverter\n"
"        {\n"
"        public:\n"
"            const char* signature() override { return \"D\"; }\n"
"\n"
"            using ManagedType = double;\n"
"            using KotlinType = jdouble;\n"
"            using KotlinWrapperType = jobject;\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<ManagedType>(value);\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return env->CallDoubleMethod(value, helper._KDouble_doubleValue);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return env->NewObject(helper._KDouble, helper._KDouble_init, value);\n"
"            }\n"
"        };\n"
"        class KString : public KotlinTypeConverter\n"
"        {\n"
"        public:\n"
"            const char* signature() override { return \"Ljava/lang/String;\"; }\n"
"\n"
"            using ManagedType = std::string;\n"
"            using KotlinType = jstring;\n"
"            using KotlinWrapperType = jobject;\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                const char* ret = env->GetStringUTFChars(value, nullptr);\n"
"                return ManagedType(ret);\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                return env->NewStringUTF(value.c_str());\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return reinterpret_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return reinterpret_cast<KotlinWrapperType>(value);\n"
"            }\n"
"        };\n"
"\n"
"        // class Enum; (생성 규칙에 의해 만들어짐)\n"
"        class KEnum : public KotlinTypeConverter\n"
"        {\n"
"        public:\n"
"            const char* signature() override { return \"I\"; }\n"
"\n"
"            using ManagedType = int32_t;\n"
"            using KotlinType = jint;\n"
"            // Kotlin.Int\n"
"            using KotlinWrapperType = jobject;\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<ManagedType>(value);\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return env->CallIntMethod(value, helper._KInt_intValue);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return env->NewObject(helper._KInt, helper._KInt_init, value);\n"
"            }\n"
"        };\n"
"\n"
"\n"
"        // class Object; (생성 규칙에 의해 만들어짐)\n"
"        class KObject : public KotlinTypeConverter\n"
"        {\n"
"        public:\n"
"            const char* signature() override { return \"J\"; }\n"
"\n"
"            using ManagedType = void*;\n"
"            using KotlinType = jlong;\n"
"            // Kotlin.Long\n"
"            using KotlinWrapperType = jobject;\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                return reinterpret_cast<ManagedType>(value);\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                return reinterpret_cast<jlong>(value);\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return env->CallLongMethod(value, helper._KLong_longValue);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return env->NewObject(helper._KLong, helper._KLong_init, value);\n"
"            }\n"
"        };\n"
"\n"
"        template<class KotlinReturnType, class... KotlinArgumentType>\n"
"        class KCallback : public KotlinTypeConverter\n"
"        {\n"
"        public:\n"
"            const char* signature() override\n"
"            {\n"
"                assert(\"Kotlin Callback cannot be used as a Callback, Array, or Vector argument.\");\n"
"                return nullptr;\n"
"            }\n"
"\n"
"            static_assert(std::is_base_of<KotlinTypeConverter, KotlinReturnType>::value, \"KotlinReturnType must be derived from KotlinTypeConverter\");\n"
"            static_assert(std::conjunction<std::is_base_of<KotlinTypeConverter, KotlinArgumentType>...>::value, \"All KotlinArgumentType must be derived from KotlinTypeConverter\");\n"
"\n"
"            using ManagedType = std::function<typename KotlinReturnType::ManagedType(typename KotlinArgumentType::ManagedType...)>;\n"
"            using KotlinType = jobject;\n"
"            using KotlinWrapperType = jobject;\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value)\n"
"            {\n"
"                auto jcallback = env->NewGlobalRef(value);\n"
"\n"
"                return [&, jcallback](typename KotlinArgumentType::ManagedType... args) -> typename KotlinReturnType::ManagedType\n"
"                {\n"
"                    size_t arg_size = sizeof...(KotlinArgumentType);\n"
"                    size_t index {1};\n"
"                    const char* sig = \"Ljava/lang/Object;\";\n"
"                    size_t sig_size = strlen(sig);\n"
"                    char invoke_signature[256]{ 0 };\n"
"                    invoke_signature[0] = '(';\n"
"                    for (size_t i =0;i<arg_size;i++)\n"
"                    {\n"
"                        std::strcpy(invoke_signature + index, sig);\n"
"                        index += sig_size;\n"
"                    }\n"
"                    invoke_signature[index++] = ')';\n"
"                    std::strcpy(invoke_signature + index, sig);\n"
"\n"
"                    bool load_error {false};\n"
"\n"
"                    JNIEnv* env {nullptr};\n"
"                    int getEnvStat = jvm->GetEnv((void **)&env, JNI_VERSION_1_6);\n"
"                    if (getEnvStat == JNI_EDETACHED) {\n"
"                        if (jvm->AttachCurrentThread(&env, NULL) != 0) {\n"
"                            load_error= true;\n"
"                        }\n"
"                    }\n"
"                    else if (getEnvStat == JNI_EVERSION) {\n"
"                        load_error = true;\n"
"                    }\n"
"                    else if (getEnvStat == JNI_OK) {\n"
"                    }\n"
"\n"
"                    if (load_error) {\n"
"                        if constexpr (std::is_same_v<KotlinReturnType, KVoid>) {\n"
"                            return;\n"
"                        } else {\n"
"                            return typename KotlinReturnType::ManagedType();\n"
"                        }\n"
"                    }\n"
"\n"
"                    jclass clazz = env->GetObjectClass(jcallback);\n"
"                    jmethodID callback = env->GetMethodID(clazz, \"invoke\", invoke_signature);\n"
"\n"
"\n"
"                    if constexpr(std::is_same_v<KotlinReturnType, KVoid>)\n"
"                    {\n"
"                        env->CallObjectMethod(jcallback, callback,\n"
"                                            KotlinArgumentType().toKotlinWrapperType(env, KotlinArgumentType().toKotlinType(env, args))...);\n"
"                        if (getEnvStat == JNI_EDETACHED)\n"
"                            jvm->DetachCurrentThread();\n"
"                        return;\n"
"                    }\n"
"                    else\n"
"                    {\n"
"                        typename KotlinReturnType::ManagedType ret;\n"
"\n"
"                        auto _ret = env->CallObjectMethod(jcallback, callback, KotlinArgumentType().toKotlinWrapperType(env, KotlinArgumentType().toKotlinType(env, args))...);\n"
"                        ret = KotlinReturnType().toManagedType(env, KotlinReturnType().toKotlinType(env, _ret));\n"
"\n"
"                        if (getEnvStat == JNI_EDETACHED)\n"
"                            jvm->DetachCurrentThread();\n"
"                        return ret;\n"
"                    }\n"
"\n"
"               };\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value)\n"
"            {\n"
"                assert(\"Managed Callback cannot be chanaged as Kotlin Callback.\");\n"
"                return nullptr;\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return value;\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return value;\n"
"            }\n"
"        private:\n"
"\n"
"\n"
"        };\n"
"\n"
"        template<typename KotlinElementType, size_t size, typename = void >\n"
"        class KArray : public KotlinTypeConverter\n"
"        {\n"
"        public:\n"
"            virtual const char* signature() = 0;\n"
"        };\n"
"\n"
"        template<size_t size>\n"
"        class KArray<KBoolean, size> : public KotlinTypeConverter\n"
"        {\n"
"        public:\n"
"            using ManagedType = std::array<bool, size>;\n"
"            using KotlinType = jbooleanArray;\n"
"\n"
"            const char* signature() override { return \"[Z\"; };\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                auto src = env->GetBooleanArrayElements(value, nullptr);\n"
"                size_t length = env->GetArrayLength(value);\n"
"                ManagedType ret;\n"
"                std::copy(src, src + length, ret.data());\n"
"                return ret;\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                KotlinType ret = env->NewBooleanArray(value.size());\n"
"                auto* arr = env->GetBooleanArrayElements(ret, nullptr);\n"
"                if (!arr)\n"
"                    return nullptr;\n"
"\n"
"                std::copy(value.begin(), value.end(), arr);\n"
"                env->ReleaseBooleanArrayElements(ret, arr, 0);\n"
"                return ret;\n"
"            }\n"
"            void copy(JNIEnv* env, const ManagedType& src, KotlinType& dest)\n"
"            {\n"
"                auto* arr = env->GetBooleanArrayElements(dest, nullptr);\n"
"                if (!arr)\n"
"                    return;\n"
"\n"
"                std::copy(src.begin(), src.end(), arr);\n"
"                env->ReleaseBooleanArrayElements(dest, arr, 0);\n"
"            }\n"
"\n"
"            using KotlinWrapperType = jobject;\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<jobject>(value);\n"
"            }\n"
"        };\n"
"\n"
"        template<size_t size>\n"
"        class KArray<KInt8, size> : public KotlinTypeConverter\n"
"        {\n"
"        public:\n"
"            const char* signature() override { return \"[B\"; };\n"
"\n"
"            using ManagedType = std::array<int8_t, size>;\n"
"            using KotlinType = jbyteArray;\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                auto src = env->GetByteArrayElements(value, nullptr);\n"
"                size_t length = env->GetArrayLength(value);\n"
"                ManagedType ret;\n"
"                std::copy(src, src + length, ret.data());\n"
"                return ret;\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                KotlinType ret = env->NewByteArray(value.size());\n"
"                auto* arr = env->GetByteArrayElements(ret, nullptr);\n"
"                if (!arr)\n"
"                    return nullptr;\n"
"\n"
"                std::copy(value.begin(), value.end(), arr);\n"
"                env->ReleaseByteArrayElements(ret, arr, 0);\n"
"                return ret;\n"
"            }\n"
"            void copy(JNIEnv* env, const ManagedType& src, KotlinType& dest)\n"
"            {\n"
"                auto* arr = env->GetByteArrayElements(dest, nullptr);\n"
"                if (!arr)\n"
"                    return;\n"
"\n"
"                std::copy(src.begin(), src.end(), arr);\n"
"                env->ReleaseByteArrayElements(dest, arr, 0);\n"
"            }\n"
"\n"
"            using KotlinWrapperType = jobject;\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<jobject>(value);\n"
"            }\n"
"        };\n"
"\n"
"        template<size_t size>\n"
"        class KArray<KInt16, size> : public KotlinTypeConverter\n"
"        {\n"
"        public:\n"
"            const char* signature() override { return \"[S\"; };\n"
"\n"
"            using ManagedType = std::array<int16_t, size>;\n"
"            using KotlinType = jshortArray;\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                auto src = env->GetShortArrayElements(value, nullptr);\n"
"                size_t length = env->GetArrayLength(value);\n"
"                ManagedType ret;\n"
"                std::copy(src, src + length, ret.data());\n"
"                return ret;\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                KotlinType ret = env->NewShortArray(value.size());\n"
"                auto* arr = env->GetShortArrayElements(ret, nullptr);\n"
"                if (!arr)\n"
"                    return nullptr;\n"
"\n"
"                std::copy(value.begin(), value.end(), arr);\n"
"                env->ReleaseShortArrayElements(ret, arr, 0);\n"
"                return ret;\n"
"            }\n"
"            void copy(JNIEnv* env, const ManagedType& src, KotlinType& dest)\n"
"            {\n"
"                auto* arr = env->GetShortArrayElements(dest, nullptr);\n"
"                if (!arr)\n"
"                    return;\n"
"\n"
"                std::copy(src.begin(), src.end(), arr);\n"
"                env->ReleaseShortArrayElements(dest, arr, 0);\n"
"            }\n"
"\n"
"            using KotlinWrapperType = jobject;\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<jobject>(value);\n"
"            }\n"
"        };\n"
"\n"
"        template<size_t size>\n"
"        class KArray<KInt32, size> : public KotlinTypeConverter\n"
"        {\n"
"        public:\n"
"            const char* signature() override { return \"[I\"; };\n"
"\n"
"            using ManagedType = std::array<int32_t, size>;\n"
"            using KotlinType = jintArray;\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                auto src = env->GetIntArrayElements(value, nullptr);\n"
"                size_t length = env->GetArrayLength(value);\n"
"                ManagedType ret;\n"
"                std::copy(src, src + length, ret.data());\n"
"                return ret;\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                KotlinType ret = env->NewIntArray(value.size());\n"
"                auto* arr = env->GetIntArrayElements(ret, nullptr);\n"
"                if (!arr)\n"
"                    return nullptr;\n"
"\n"
"                std::copy(value.begin(), value.end(), arr);\n"
"                env->ReleaseIntArrayElements(ret, arr, 0);\n"
"                return ret;\n"
"            }\n"
"            void copy(JNIEnv* env, const ManagedType& src, KotlinType& dest)\n"
"            {\n"
"                auto* arr = env->GetIntArrayElements(dest, nullptr);\n"
"                if (!arr)\n"
"                    return;\n"
"\n"
"                std::copy(src.begin(), src.end(), arr);\n"
"                env->ReleaseIntArrayElements(dest, arr, 0);\n"
"            }\n"
"\n"
"            using KotlinWrapperType = jobject;\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<jobject>(value);\n"
"            }\n"
"        };\n"
"\n"
"        template<size_t size>\n"
"        class KArray<KInt64, size> : public KotlinTypeConverter\n"
"        {\n"
"        public:\n"
"            const char* signature() override { return \"[J\"; };\n"
"\n"
"            using ManagedType = std::array<int64_t, size>;\n"
"            using KotlinType = jlongArray;\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                auto src = env->GetLongArrayElements(value, nullptr);\n"
"                size_t length = env->GetArrayLength(value);\n"
"                ManagedType ret;\n"
"                std::copy(src, src + length, ret.data());\n"
"                return ret;\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                KotlinType ret = env->NewLongArray(value.size());\n"
"                auto* arr = env->GetLongArrayElements(ret, nullptr);\n"
"                if (!arr)\n"
"                    return nullptr;\n"
"\n"
"                std::copy(value.begin(), value.end(), arr);\n"
"                env->ReleaseLongArrayElements(ret, arr, 0);\n"
"                return ret;\n"
"            }\n"
"            void copy(JNIEnv* env, const ManagedType& src, KotlinType& dest)\n"
"            {\n"
"                auto* arr = env->GetLongArrayElements(dest, nullptr);\n"
"                if (!arr)\n"
"                    return;\n"
"\n"
"                std::copy(src.begin(), src.end(), arr);\n"
"                env->ReleaseLongArrayElements(dest, arr, 0);\n"
"            }\n"
"\n"
"            using KotlinWrapperType = jobject;\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<jobject>(value);\n"
"            }\n"
"        };\n"
"\n"
"        template<size_t size>\n"
"        class KArray<KFloat, size> : public KotlinTypeConverter\n"
"        {\n"
"        public:\n"
"            const char* signature() override { return \"[F\"; };\n"
"\n"
"            using ManagedType = std::array<float, size>;\n"
"            using KotlinType = jfloatArray;\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                auto src = env->GetFloatArrayElements(value, nullptr);\n"
"                size_t length = env->GetArrayLength(value);\n"
"                ManagedType ret;\n"
"                std::copy(src, src + length, ret.data());\n"
"                return ret;\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                KotlinType ret = env->NewFloatArray(value.size());\n"
"                auto* arr = env->GetFloatArrayElements(ret, nullptr);\n"
"                if (!arr)\n"
"                    return nullptr;\n"
"\n"
"                std::copy(value.begin(), value.end(), arr);\n"
"                env->ReleaseFloatArrayElements(ret, arr, 0);\n"
"                return ret;\n"
"            }\n"
"            void copy(JNIEnv* env, const ManagedType& src, KotlinType& dest)\n"
"            {\n"
"                auto* arr = env->GetFloatArrayElements(dest, nullptr);\n"
"                if (!arr)\n"
"                    return;\n"
"\n"
"                std::copy(src.begin(), src.end(), arr);\n"
"                env->ReleaseFloatArrayElements(dest, arr, 0);\n"
"            }\n"
"\n"
"            using KotlinWrapperType = jobject;\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<jobject>(value);\n"
"            }\n"
"        };\n"
"\n"
"        template<size_t size>\n"
"        class KArray<KDouble, size> : public KotlinTypeConverter\n"
"        {\n"
"        public:\n"
"            const char* signature() override { return \"[D\"; };\n"
"\n"
"            using ManagedType = std::array<double, size>;\n"
"            using KotlinType = jdoubleArray;\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                auto src = env->GetDoubleArrayElements(value, nullptr);\n"
"                size_t length = env->GetArrayLength(value);\n"
"                ManagedType ret;\n"
"                std::copy(src, src + length, ret.data());\n"
"                return ret;\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                KotlinType ret = env->NewDoubleArray(value.size());\n"
"                auto* arr = env->GetDoubleArrayElements(ret, nullptr);\n"
"                if (!arr)\n"
"                    return nullptr;\n"
"\n"
"                std::copy(value.begin(), value.end(), arr);\n"
"                env->ReleaseDoubleArrayElements(ret, arr, 0);\n"
"                return ret;\n"
"            }\n"
"            void copy(JNIEnv* env, const ManagedType& src, KotlinType& dest)\n"
"            {\n"
"                auto* arr = env->GetDoubleArrayElements(dest, nullptr);\n"
"                if (!arr)\n"
"                    return;\n"
"\n"
"                std::copy(src.begin(), src.end(), arr);\n"
"                env->ReleaseDoubleArrayElements(dest, arr, 0);\n"
"            }\n"
"\n"
"            using KotlinWrapperType = jobject;\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<jobject>(value);\n"
"            }\n"
"        };\n"
"\n"
"        template<size_t size>\n"
"        class KArray<KString, size> : public KotlinTypeConverter\n"
"        {\n"
"        public:\n"
"            const char* signature() override { return \"[Ljava/lang/String;\"; };\n"
"\n"
"            using ManagedType = std::array<std::string, size>;\n"
"            using KotlinType = jobjectArray;\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                size_t length = env->GetArrayLength(value);\n"
"\n"
"                ManagedType ret;\n"
"                for (size_t i = 0; i < length; i++)\n"
"                {\n"
"                    auto element = env->GetObjectArrayElement(value, i);\n"
"                    auto new_element = KString().toManagedType(env, (jstring)element);\n"
"                    ret[i] = new_element;\n"
"                }\n"
"\n"
"                return ret;\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                KotlinType ret = env->NewObjectArray(value.size(), helper._KString, nullptr);\n"
"                for (size_t i =0;i<value.size();i++)\n"
"                {\n"
"                    auto element = value[i];\n"
"                    auto new_element = KString().toKotlinType(env, element);\n"
"                    env->SetObjectArrayElement(ret, i, new_element);\n"
"                }\n"
"                return ret;\n"
"            }\n"
"            void copy(JNIEnv* env, const ManagedType& src, KotlinType& dest)\n"
"            {\n"
"                for (size_t i =0;i<src.size();i++)\n"
"                {\n"
"                    auto element = src[i];\n"
"                    auto new_element = KString().toKotlinType(env, element);\n"
"                    env->SetObjectArrayElement(dest, i, new_element);\n"
"                }\n"
"            }\n"
"\n"
"            using KotlinWrapperType = jobject;\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<jobject>(value);\n"
"            }\n"
"        };\n"
"\n"
"        template<size_t size>\n"
"        class KArray<KEnum, size> : public KotlinTypeConverter\n"
"        {\n"
"        public:\n"
"            const char* signature() override {\n"
"                return \"[I\";\n"
"            }\n"
"\n"
"            using ManagedType = std::array<int32_t, size>;\n"
"            using KotlinType = jintArray;\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                auto src = env->GetIntArrayElements(value, nullptr);\n"
"                size_t length = env->GetArrayLength(value);\n"
"                ManagedType ret;\n"
"                std::copy(src, src + length, ret.data());\n"
"                return ret;\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                KotlinType ret = env->NewIntArray(value.size());\n"
"                auto* arr = env->GetIntArrayElements(ret, nullptr);\n"
"                if (!arr)\n"
"                    return nullptr;\n"
"\n"
"                std::copy(value.begin(), value.end(), arr);\n"
"                env->ReleaseIntArrayElements(ret, arr, 0);\n"
"                return ret;\n"
"            }\n"
"            void copy(JNIEnv* env, const ManagedType& src, KotlinType& dest)\n"
"            {\n"
"                auto* arr = env->GetIntArrayElements(dest, nullptr);\n"
"                if (!arr)\n"
"                    return;\n"
"\n"
"                std::copy(src.begin(), src.end(), arr);\n"
"                env->ReleaseIntArrayElements(dest, arr, 0);\n"
"            }\n"
"\n"
"            using KotlinWrapperType = jobject;\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<jobject>(value);\n"
"            }\n"
"        };\n"
"        \n"
"        template<typename KObject, size_t size>\n"
"        class KArray<KObject, size> : public KotlinTypeConverter\n"
"        {\n"
"        public:\n"
"            const char* signature() override {\n"
"                return \"[J\";\n"
"            }\n"
"\n"
"            using ManagedType = std::array<void*, size>;\n"
"            using KotlinType = jlongArray;\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                auto src = env->GetLongArrayElements(value, nullptr);\n"
"                size_t length = env->GetArrayLength(value);\n"
"                ManagedType ret;\n"
"\n"
"                for (size_t i=0;i<length;i++)\n"
"                    ret[i]= KObject().toManagedType(env, src[i]);\n"
"\n"
"                return ret;\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                KotlinType ret = env->NewLongArray(value.size());\n"
"                auto* arr = env->GetLongArrayElements(ret, nullptr);\n"
"                if (!arr)\n"
"                    return nullptr;\n"
"\n"
"                for (size_t i =0; i <value.size(); i++)\n"
"                    arr[i] = KObject().toKotlinType(env, value[i]);\n"
"\n"
"                env->ReleaseLongArrayElements(ret, arr, 0);\n"
"                return ret;\n"
"            }\n"
"            void copy(JNIEnv* env, const ManagedType& src, KotlinType& dest) {\n"
"                auto *arr = env->GetLongArrayElements(dest, nullptr);\n"
"                if (!arr)\n"
"                    return;\n"
"\n"
"                for (size_t i = 0; i < src.size(); i++) {\n"
"                    arr[i] = KObject().toKotlinType(env, src[i]);\n"
"                }\n"
"\n"
"                env->ReleaseLongArrayElements(dest, arr, 0);\n"
"            }\n"
"\n"
"            using KotlinWrapperType = jobject;\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<jobject>(value);\n"
"            }\n"
"        };\n"
"\n"
"        template<size_t size, class KotlinReturnType, class... KotlinArgumentType>\n"
"        class KArray<KCallback<KotlinReturnType, KotlinArgumentType...>, size> : public KotlinTypeConverter\n"
"        {\n"
"        public:\n"
"\n"
"            using Callback = KCallback<KotlinReturnType, KotlinArgumentType...>;\n"
"            using ManagedType = std::vector<void*>;\n"
"            using KotlinType = jobjectArray;\n"
"\n"
"            const char* signature() override {\n"
"                assert(\"Kotlin Callback cannot be used as a Callback, Array, or Vector argument.\");\n"
"                return nullptr;\n"
"            }\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                size_t length = env->GetArrayLength(value);\n"
"\n"
"                ManagedType ret;\n"
"                ret.reserve(length);\n"
"                for (size_t i = 0; i < length; i++)\n"
"                {\n"
"                    auto element = env->GetObjectArrayElement(value, i);\n"
"                    auto new_element = Callback().toManagedType(element);\n"
"                    ret.push_back(new_element);\n"
"                }\n"
"\n"
"                return ret;\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                auto clazz = env->FindClass(Callback().className());\n"
"                KotlinType ret = env->NewObjectArray(value.size(), clazz, nullptr);\n"
"                for (size_t i =0;i<value.size();i++)\n"
"                {\n"
"                    auto element = value[i];\n"
"                    auto new_element = Callback().toKotlinType(element);\n"
"                    auto* arr = env->SetObjectArrayElement(ret, i, new_element);\n"
"                }\n"
"                return ret;\n"
"            }\n"
"            void copy(JNIEnv* env, const ManagedType& src, KotlinType& dest)\n"
"            {\n"
"                for (size_t i =0;i<src.size();i++)\n"
"                {\n"
"                    auto element = src[i];\n"
"                    auto new_element = Callback().toKotlinType(element);\n"
"                    auto* arr = env->SetObjectArrayElement(dest, i, new_element);\n"
"                }\n"
"            }\n"
"\n"
"            using KotlinWrapperType = jobject;\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<KotlinWrapperType>(value);\n"
"            }\n"
"        };\n"
"\n"
"\n"
"        template<class KotlinElementType, typename = void>\n"
"        class KVector : public KotlinTypeConverter\n"
"        {\n"
"            const char* signature() override {\n"
"                return \"Ljava/lang/ArrayList;\";\n"
"            }\n"
"        };\n"
"\n"
"        template<>\n"
"        struct KVector<KBoolean> : public KotlinTypeConverter\n"
"        {\n"
"            using ManagedType = std::vector<bool>;\n"
"            using KotlinType = jobject;\n"
"            using KotlinElementType = KBoolean;\n"
"            const char* signature() override {\n"
"                return \"Ljava/lang/ArrayList;\";\n"
"            }\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                auto size = env->CallIntMethod(value, helper._KVector_size);\n"
"                ManagedType ret;\n"
"\n"
"                for (size_t i = 0; i < size; i++)\n"
"                {\n"
"                    auto ko_element = env->CallObjectMethod(value, helper._KVector_get, i);\n"
"                    auto k_element = KotlinElementType().toKotlinType(env, ko_element);\n"
"                    ret.push_back(KotlinElementType().toManagedType(env, k_element));\n"
"                }\n"
"\n"
"                return ret;\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                KotlinType ret = env->NewObject(helper._KVector, helper._KVector_init);\n"
"                for (auto element : value)\n"
"                {\n"
"                    auto kelemnent = KotlinElementType().toKotlinType(env, element);\n"
"                    auto ko_element = KotlinElementType().toKotlinWrapperType(env, kelemnent);\n"
"                    env->CallBooleanMethod(ret, helper._KVector_add, ko_element);\n"
"                }\n"
"                return ret;\n"
"            }\n"
"            void copy(JNIEnv* env, const ManagedType& src, KotlinType& dest)\n"
"            {\n"
"                env->CallVoidMethod(dest, helper._KVector_clear);\n"
"                for (auto element : src)\n"
"                {\n"
"                    auto kelemnent = KotlinElementType().toKotlinType(env, element);\n"
"                    auto ko_element = KotlinElementType().toKotlinWrapperType(env, kelemnent);\n"
"                    env->CallBooleanMethod(dest, helper._KVector_add, ko_element);\n"
"                }\n"
"            }\n"
"\n"
"            using KotlinWrapperType = jobject;\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<KotlinWrapperType>(value);\n"
"            }\n"
"        };\n"
"\n"
"        template<>\n"
"        struct KVector<KInt8> : public KotlinTypeConverter\n"
"        {\n"
"            using ManagedType = std::vector<int8_t>;\n"
"            using KotlinType = jobject;\n"
"            using KotlinElementType = KInt8;\n"
"\n"
"            const char* signature() override {\n"
"                return \"Ljava/lang/ArrayList;\";\n"
"            }\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                auto size = env->CallIntMethod(value, helper._KVector_size);\n"
"                ManagedType ret;\n"
"\n"
"                for (size_t i = 0; i < size; i++)\n"
"                {\n"
"                    auto ko_element = env->CallObjectMethod(value, helper._KVector_get, i);\n"
"                    auto k_element = KotlinElementType().toKotlinType(env, ko_element);\n"
"                    ret.push_back(KotlinElementType().toManagedType(env, k_element));\n"
"                }\n"
"\n"
"                return ret;\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                KotlinType ret = env->NewObject(helper._KVector, helper._KVector_init);\n"
"                for (auto element : value)\n"
"                {\n"
"                    auto kelemnent = KotlinElementType().toKotlinType(env, element);\n"
"                    auto ko_element = KotlinElementType().toKotlinWrapperType(env, kelemnent);\n"
"                    env->CallBooleanMethod(ret, helper._KVector_add, ko_element);\n"
"                }\n"
"                return ret;\n"
"            }\n"
"            void copy(JNIEnv* env, const ManagedType& src, KotlinType& dest)\n"
"            {\n"
"                env->CallVoidMethod(dest, helper._KVector_clear);\n"
"                for (auto element : src)\n"
"                {\n"
"                    auto kelemnent = KotlinElementType().toKotlinType(env, element);\n"
"                    auto ko_element = KotlinElementType().toKotlinWrapperType(env, kelemnent);\n"
"                    env->CallBooleanMethod(dest, helper._KVector_add, ko_element);\n"
"                }\n"
"            }\n"
"\n"
"            using KotlinWrapperType = jobject;\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<KotlinWrapperType>(value);\n"
"            }\n"
"        };\n"
"\n"
"        template<>\n"
"        struct KVector<KInt16> : public KotlinTypeConverter\n"
"        {\n"
"            using ManagedType = std::vector<int16_t>;\n"
"            using KotlinType = jobject;\n"
"            using KotlinElementType = KInt16;\n"
"\n"
"            const char* signature() override {\n"
"                return \"Ljava/lang/ArrayList;\";\n"
"            }\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                auto size = env->CallIntMethod(value, helper._KVector_size);\n"
"                ManagedType ret;\n"
"\n"
"                for (size_t i = 0; i < size; i++)\n"
"                {\n"
"                    auto ko_element = env->CallObjectMethod(value, helper._KVector_get, i);\n"
"                    auto k_element = KotlinElementType().toKotlinType(env, ko_element);\n"
"                    ret.push_back(KotlinElementType().toManagedType(env, k_element));\n"
"                }\n"
"\n"
"                return ret;\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                KotlinType ret = env->NewObject(helper._KVector, helper._KVector_init);\n"
"                for (auto element : value)\n"
"                {\n"
"                    auto kelemnent = KotlinElementType().toKotlinType(env, element);\n"
"                    auto ko_element = KotlinElementType().toKotlinWrapperType(env, kelemnent);\n"
"                    env->CallBooleanMethod(ret, helper._KVector_add, ko_element);\n"
"                }\n"
"                return ret;\n"
"            }\n"
"            void copy(JNIEnv* env, const ManagedType& src, KotlinType& dest)\n"
"            {\n"
"                env->CallVoidMethod(dest, helper._KVector_clear);\n"
"                for (auto element : src)\n"
"                {\n"
"                    auto kelemnent = KotlinElementType().toKotlinType(env, element);\n"
"                    auto ko_element = KotlinElementType().toKotlinWrapperType(env, kelemnent);\n"
"                    env->CallBooleanMethod(dest, helper._KVector_add, ko_element);\n"
"                }\n"
"            }\n"
"\n"
"            using KotlinWrapperType = jobject;\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<KotlinWrapperType>(value);\n"
"            }\n"
"        };\n"
"\n"
"        template<>\n"
"        struct KVector<KInt32> : public KotlinTypeConverter\n"
"        {\n"
"            using ManagedType = std::vector<int32_t>;\n"
"            using KotlinType = jobject;\n"
"            using KotlinElementType = KInt32;\n"
"\n"
"            const char* signature() override {\n"
"                return \"Ljava/lang/ArrayList;\";\n"
"            }\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                auto size = env->CallIntMethod(value, helper._KVector_size);\n"
"                ManagedType ret;\n"
"\n"
"                for (size_t i = 0; i < size; i++)\n"
"                {\n"
"                    auto ko_element = env->CallObjectMethod(value, helper._KVector_get, i);\n"
"                    auto k_element = KotlinElementType().toKotlinType(env, ko_element);\n"
"                    ret.push_back(KotlinElementType().toManagedType(env, k_element));\n"
"                }\n"
"\n"
"                return ret;\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                KotlinType ret = env->NewObject(helper._KVector, helper._KVector_init);\n"
"                for (auto element : value)\n"
"                {\n"
"                    auto kelemnent = KotlinElementType().toKotlinType(env, element);\n"
"                    auto ko_element = KotlinElementType().toKotlinWrapperType(env, kelemnent);\n"
"                    env->CallBooleanMethod(ret, helper._KVector_add, ko_element);\n"
"                }\n"
"                return ret;\n"
"            }\n"
"            void copy(JNIEnv* env, const ManagedType& src, KotlinType& dest)\n"
"            {\n"
"                env->CallVoidMethod(dest, helper._KVector_clear);\n"
"                for (auto element : src)\n"
"                {\n"
"                    auto kelemnent = KotlinElementType().toKotlinType(env, element);\n"
"                    auto ko_element = KotlinElementType().toKotlinWrapperType(env, kelemnent);\n"
"                    env->CallBooleanMethod(dest, helper._KVector_add, ko_element);\n"
"                }\n"
"            }\n"
"\n"
"            using KotlinWrapperType = jobject;\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<KotlinWrapperType>(value);\n"
"            }\n"
"        };\n"
"\n"
"        template<>\n"
"        struct KVector<KInt64> : public KotlinTypeConverter\n"
"        {\n"
"            using ManagedType = std::vector<int64_t>;\n"
"            using KotlinType = jobject;\n"
"            using KotlinElementType = KInt64;\n"
"\n"
"            const char* signature() override {\n"
"                return \"Ljava/lang/ArrayList;\";\n"
"            }\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                auto size = env->CallIntMethod(value, helper._KVector_size);\n"
"                ManagedType ret;\n"
"\n"
"                for (size_t i = 0; i < size; i++)\n"
"                {\n"
"                    auto ko_element = env->CallObjectMethod(value, helper._KVector_get, i);\n"
"                    auto k_element = KotlinElementType().toKotlinType(env, ko_element);\n"
"                    ret.push_back(KotlinElementType().toManagedType(env, k_element));\n"
"                }\n"
"\n"
"                return ret;\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                KotlinType ret = env->NewObject(helper._KVector, helper._KVector_init);\n"
"                for (auto element : value)\n"
"                {\n"
"                    auto kelemnent = KotlinElementType().toKotlinType(env, element);\n"
"                    auto ko_element = KotlinElementType().toKotlinWrapperType(env, kelemnent);\n"
"                    env->CallBooleanMethod(ret, helper._KVector_add, ko_element);\n"
"                }\n"
"                return ret;\n"
"            }\n"
"            void copy(JNIEnv* env, const ManagedType& src, KotlinType& dest)\n"
"            {\n"
"                env->CallVoidMethod(dest, helper._KVector_clear);\n"
"                for (auto element : src)\n"
"                {\n"
"                    auto kelemnent = KotlinElementType().toKotlinType(env, element);\n"
"                    auto ko_element = KotlinElementType().toKotlinWrapperType(env, kelemnent);\n"
"                    env->CallBooleanMethod(dest, helper._KVector_add, ko_element);\n"
"                }\n"
"            }\n"
"\n"
"            using KotlinWrapperType = jobject;\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<KotlinWrapperType>(value);\n"
"            }\n"
"        };\n"
"\n"
"        template<>\n"
"        struct KVector<KFloat> : public KotlinTypeConverter\n"
"        {\n"
"            using ManagedType = std::vector<float>;\n"
"            using KotlinType = jobject;\n"
"            using KotlinElementType = KFloat;\n"
"\n"
"            const char* signature() override {\n"
"                return \"Ljava/lang/ArrayList;\";\n"
"            }\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                auto size = env->CallIntMethod(value, helper._KVector_size);\n"
"                ManagedType ret;\n"
"\n"
"                for (size_t i = 0; i < size; i++)\n"
"                {\n"
"                    auto ko_element = env->CallObjectMethod(value, helper._KVector_get, i);\n"
"                    auto k_element = KotlinElementType().toKotlinType(env, ko_element);\n"
"                    ret.push_back(KotlinElementType().toManagedType(env, k_element));\n"
"                }\n"
"\n"
"                return ret;\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                KotlinType ret = env->NewObject(helper._KVector, helper._KVector_init);\n"
"                for (auto element : value)\n"
"                {\n"
"                    auto kelemnent = KotlinElementType().toKotlinType(env, element);\n"
"                    auto ko_element = KotlinElementType().toKotlinWrapperType(env, kelemnent);\n"
"                    env->CallBooleanMethod(ret, helper._KVector_add, ko_element);\n"
"                }\n"
"                return ret;\n"
"            }\n"
"            void copy(JNIEnv* env, const ManagedType& src, KotlinType& dest)\n"
"            {\n"
"                env->CallVoidMethod(dest, helper._KVector_clear);\n"
"                for (auto element : src)\n"
"                {\n"
"                    auto kelemnent = KotlinElementType().toKotlinType(env, element);\n"
"                    auto ko_element = KotlinElementType().toKotlinWrapperType(env, kelemnent);\n"
"                    env->CallBooleanMethod(dest, helper._KVector_add, ko_element);\n"
"                }\n"
"            }\n"
"\n"
"            using KotlinWrapperType = jobject;\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<KotlinWrapperType>(value);\n"
"            }\n"
"        };\n"
"\n"
"        template<>\n"
"        struct KVector<KDouble> : public KotlinTypeConverter\n"
"        {\n"
"            using ManagedType = std::vector<double>;\n"
"            using KotlinType = jobject;\n"
"            using KotlinElementType = KDouble;\n"
"\n"
"            const char* signature() override {\n"
"                return \"Ljava/lang/ArrayList;\";\n"
"            }\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                auto size = env->CallIntMethod(value, helper._KVector_size);\n"
"                ManagedType ret;\n"
"\n"
"                for (size_t i = 0; i < size; i++)\n"
"                {\n"
"                    auto ko_element = env->CallObjectMethod(value, helper._KVector_get, i);\n"
"                    auto k_element = KotlinElementType().toKotlinType(env, ko_element);\n"
"                    ret.push_back(KotlinElementType().toManagedType(env, k_element));\n"
"                }\n"
"\n"
"                return ret;\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                KotlinType ret = env->NewObject(helper._KVector, helper._KVector_init);\n"
"                for (auto element : value)\n"
"                {\n"
"                    auto kelemnent = KotlinElementType().toKotlinType(env, element);\n"
"                    auto ko_element = KotlinElementType().toKotlinWrapperType(env, kelemnent);\n"
"                    env->CallBooleanMethod(ret, helper._KVector_add, ko_element);\n"
"                }\n"
"                return ret;\n"
"            }\n"
"            void copy(JNIEnv* env, const ManagedType& src, KotlinType& dest)\n"
"            {\n"
"                env->CallVoidMethod(dest, helper._KVector_clear);\n"
"                for (auto element : src)\n"
"                {\n"
"                    auto kelemnent = KotlinElementType().toKotlinType(env, element);\n"
"                    auto ko_element = KotlinElementType().toKotlinWrapperType(env, kelemnent);\n"
"                    env->CallBooleanMethod(dest, helper._KVector_add, ko_element);\n"
"                }\n"
"            }\n"
"\n"
"            using KotlinWrapperType = jobject;\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<KotlinWrapperType>(value);\n"
"            }\n"
"        };\n"
"\n"
"        template<>\n"
"        struct KVector<KString> : public KotlinTypeConverter\n"
"        {\n"
"            using NativeType = std::vector<std::string>;\n"
"            using ManagedType = NativeType;\n"
"            using KotlinType = jobject;\n"
"\n"
"            const char* signature() override {\n"
"                return \"Ljava/lang/ArrayList;\";\n"
"            }\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                auto size = env->CallIntMethod(value, helper._KVector_size);\n"
"                ManagedType ret;\n"
"\n"
"                for (size_t i = 0; i < size; i++)\n"
"                {\n"
"                    auto ko_element = env->CallObjectMethod(value, helper._KVector_get, i);\n"
"                    auto k_element = KString().toKotlinType(env, ko_element);\n"
"                    ret.push_back(KString().toManagedType(env, k_element));\n"
"                }\n"
"\n"
"                return ret;\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                KotlinType ret = env->NewObject(helper._KVector, helper._KVector_init);\n"
"                for (auto element : value)\n"
"                {\n"
"                    auto kelemnent = KString().toKotlinType(env, element);\n"
"                    auto ko_element = KString().toKotlinWrapperType(env, kelemnent);\n"
"                    env->CallBooleanMethod(ret, helper._KVector_add, ko_element);\n"
"                }\n"
"                return ret;\n"
"            }\n"
"            void copy(JNIEnv* env, const ManagedType& src, KotlinType& dest)\n"
"            {\n"
"                env->CallVoidMethod(dest, helper._KVector_clear);\n"
"                for (auto element : src)\n"
"                {\n"
"                    auto kelemnent = KString().toKotlinType(env, element);\n"
"                    auto ko_element = KString().toKotlinWrapperType(env, kelemnent);\n"
"                    env->CallBooleanMethod(dest, helper._KVector_add, ko_element);\n"
"                }\n"
"            }\n"
"\n"
"            using KotlinWrapperType = jobject;\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<KotlinWrapperType>(value);\n"
"            }\n"
"        };\n"
"\n"
"        template<typename KDerivedEnum>\n"
"        struct KVector<KDerivedEnum, typename std::enable_if<std::is_base_of<KEnum, KDerivedEnum>::value>::type> : public KotlinTypeConverter\n"
"        {\n"
"            using ManagedType = std::vector<int32_t>;\n"
"            using KotlinType = jobject;\n"
"            using KotlinElementType = KDerivedEnum;\n"
"\n"
"            const char* signature() override {\n"
"                return \"Ljava/lang/ArrayList;\";\n"
"            }\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                auto size = env->CallIntMethod(value, helper._KVector_size);\n"
"                ManagedType ret;\n"
"\n"
"                for (size_t i = 0; i < size; i++)\n"
"                {\n"
"                    auto ko_element = env->CallObjectMethod(value, helper._KVector_get, i);\n"
"                    auto k_element = KotlinElementType().toKotlinType(env, ko_element);\n"
"                    ret.push_back(KotlinElementType().toManagedType(env, k_element));\n"
"                }\n"
"\n"
"                return ret;\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                KotlinType ret = env->NewObject(helper._KVector, helper._KVector_init);\n"
"                for (auto element : value)\n"
"                {\n"
"                    auto kelemnent = KotlinElementType().toKotlinType(env, element);\n"
"                    auto ko_element = KotlinElementType().toKotlinWrapperType(env, kelemnent);\n"
"                    env->CallBooleanMethod(ret, helper._KVector_add, ko_element);\n"
"                }\n"
"                return ret;\n"
"            }\n"
"            void copy(JNIEnv* env, const ManagedType& src, KotlinType& dest)\n"
"            {\n"
"                env->CallVoidMethod(dest, helper._KVector_clear);\n"
"                for (auto element : src)\n"
"                {\n"
"                    auto kelemnent = KotlinElementType().toKotlinType(env, element);\n"
"                    auto ko_element = KotlinElementType().toKotlinWrapperType(env, kelemnent);\n"
"                    env->CallBooleanMethod(dest, helper._KVector_add, ko_element);\n"
"                }\n"
"            }\n"
"\n"
"            using KotlinWrapperType = jobject;\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<KotlinWrapperType>(value);\n"
"            }\n"
"        };\n"
"\n"
"        template<typename KDerivedObject>\n"
"        struct KVector<KDerivedObject, typename std::enable_if<std::is_base_of<KObject, KDerivedObject>::value>::type> : public KotlinTypeConverter\n"
"        {\n"
"            using ManagedType = std::vector<void*>;\n"
"            using KotlinType = jobject;\n"
"            using KotlinElementType = KDerivedObject;\n"
"\n"
"            const char* signature() override {\n"
"                return \"Ljava/lang/ArrayList;\";\n"
"            }\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                auto size = env->CallIntMethod(value, helper._KVector_size);\n"
"                ManagedType ret;\n"
"\n"
"                for (size_t i = 0; i < size; i++)\n"
"                {\n"
"                    auto ko_element = env->CallObjectMethod(value, helper._KVector_get, i);\n"
"                    auto k_element = KotlinElementType().toKotlinType(env, ko_element);\n"
"                    ret.push_back(KotlinElementType().toManagedType(env, k_element));\n"
"                }\n"
"\n"
"                return ret;\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                KotlinType ret = env->NewObject(helper._KVector, helper._KVector_init);\n"
"                for (auto element : value)\n"
"                {\n"
"                    auto kelemnent = KotlinElementType().toKotlinType(env, element);\n"
"                    auto ko_element = KotlinElementType().toKotlinWrapperType(env, kelemnent);\n"
"                    env->CallBooleanMethod(ret, helper._KVector_add, ko_element);\n"
"                }\n"
"                return ret;\n"
"            }\n"
"            void copy(JNIEnv* env, const ManagedType& src, KotlinType& dest)\n"
"            {\n"
"                env->CallVoidMethod(dest, helper._KVector_clear);\n"
"                for (auto element : src)\n"
"                {\n"
"                    auto kelemnent = KotlinElementType().toKotlinType(env, element);\n"
"                    auto ko_element = KotlinElementType().toKotlinWrapperType(env, kelemnent);\n"
"                    env->CallBooleanMethod(dest, helper._KVector_add, ko_element);\n"
"                }\n"
"            }\n"
"\n"
"            using KotlinWrapperType = jobject;\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<KotlinWrapperType>(value);\n"
"            }\n"
"        };\n"
"\n"
"        template<class KotlinReturnType, class... KotlinArgumentType>\n"
"        struct KVector<KCallback<KotlinReturnType, KotlinArgumentType...>> : public KotlinTypeConverter\n"
"        {\n"
"            using ManagedType = std::vector<void*>;\n"
"            using KotlinType = jobject;\n"
"\n"
"            using KotlinElementType = KCallback<KotlinReturnType, KotlinArgumentType...>;\n"
"\n"
"            const char* signature() override {\n"
"                return \"Ljava/lang/ArrayList;\";\n"
"            }\n"
"\n"
"            ManagedType toManagedType(JNIEnv* env, const KotlinType& value) {\n"
"                auto size = env->CallIntMethod(value, helper._KVector_size);\n"
"                ManagedType ret;\n"
"\n"
"                for (size_t i = 0; i < size; i++)\n"
"                {\n"
"                    auto ko_element = env->CallObjectMethod(value, helper._KVector_get, i);\n"
"                    auto k_element = KotlinElementType().toKotlinType(env, ko_element);\n"
"                    ret.push_back(KotlinElementType().toManagedType(env, k_element));\n"
"                }\n"
"\n"
"                return ret;\n"
"            }\n"
"            KotlinType toKotlinType(JNIEnv* env, const ManagedType& value) {\n"
"                KotlinType ret = env->NewObject(helper._KVector, helper._KVector_init);\n"
"                for (auto element : value)\n"
"                {\n"
"                    auto kelemnent = KotlinElementType().toKotlinType(env, element);\n"
"                    auto ko_element = KotlinElementType().toKotlinWrapperType(env, kelemnent);\n"
"                    env->CallBooleanMethod(ret, helper._KVector_add, ko_element);\n"
"                }\n"
"                return ret;\n"
"            }\n"
"            void copy(JNIEnv* env, const ManagedType& src, KotlinType& dest)\n"
"            {\n"
"                env->CallVoidMethod(dest, helper._KVector_clear);\n"
"                for (auto element : src)\n"
"                {\n"
"                    auto kelemnent = KotlinElementType().toKotlinType(env, element);\n"
"                    auto ko_element = KotlinElementType().toKotlinWrapperType(env, kelemnent);\n"
"                    env->CallBooleanMethod(dest, helper._KVector_add, ko_element);\n"
"                }\n"
"            }\n"
"\n"
"            using KotlinWrapperType = jobject;\n"
"            KotlinType toKotlinType(JNIEnv* env, const KotlinWrapperType& value) {\n"
"                return static_cast<KotlinType>(value);\n"
"            }\n"
"            KotlinWrapperType toKotlinWrapperType(JNIEnv* env, const KotlinType& value) {\n"
"                return static_cast<KotlinWrapperType>(value);\n"
"            }\n"
"        };\n"
"\n"
"    }\n"
"}\n"
"\n"
"#endif\n"
"\n";
#endif //__BN3MONKEY_LIBRARY_INTERFACE_GENERATOR_KOTLINTYPECONVERTER_HPP__
