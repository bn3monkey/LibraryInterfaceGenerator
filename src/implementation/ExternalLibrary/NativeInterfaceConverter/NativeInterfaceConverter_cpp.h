#if !defined(__BN3MONKEY_LIBRARY_INTERFACE_GENERATOR_NATIVEINTERFACECONVERTER_CPP__)
#define __BN3MONKEY_LIBRARY_INTERFACE_GENERATOR_NATIVEINTERFACECONVERTER_CPP__
static constexpr char* NATIVEINTERFACECONVERTER_CPP = 
"#include <memory>\n"
"#include <vector>\n"
"\n"
"template<class T, class ...Args>\n"
"inline void* createReference(Args... args)\n"
"{\n"
"#ifdef __LIBRARYINTERFACEGENERATOR_MEMORY_POOL__\n"
"    auto* ret = MemoryPool::allocate<std::shared_ptr<T>>();\n"
"    *ret = std::shared_ptr<T>(MemoryPool::allocate<T>(1, args...), [](T* p) {\n"
"        MemoryPool::deallocate<T>(p);\n"
"    });\n"
"#else\n"
"    auto* ret = new std::shared_ptr<T>(new T(args...));\n"
"#endif\n"
"    return ret;\n"
"}\n"
"template<class T>\n"
"inline void* createReference()\n"
"{\n"
"#ifdef __LIBRARYINTERFACEGENERATOR_MEMORY_POOL__\n"
"    auto* ret = MemoryPool::allocate<std::shared_ptr<T>>();\n"
"    Log::D(__FUNCTION__, \"ret address : %p\", ret);\n"
"    *ret = std::shared_ptr<T>(MemoryPool::allocate<T>(), [](T* p) {\n"
"        MemoryPool::deallocate<T>(p);\n"
"    });\n"
"#else\n"
"    auto* ret = new std::shared_ptr<T>();\n"
"#endif\n"
"    return ret;\n"
"}\n"
"template<class T>\n"
"inline void releaseReference(void* cptr)\n"
"{\n"
"#ifdef __LIBRARYINTERFACEGENERATOR_MEMORY_POOL__\n"
"    MemoryPool::deallocate(reinterpret_cast<std::shared_ptr<T>*>(cptr));\n"
"#else\n"
"    delete reinterpret_cast<std::shared_ptr<T>*>(cptr);\n"
"#endif\n"
"}\n"
"template<class T>\n"
"inline std::shared_ptr<T>& getReference(const void* cptr)\n"
"{\n"
"    auto* ret = const_cast<std::shared_ptr<T>*>(reinterpret_cast<const std::shared_ptr<T>*>(cptr));\n"
"    return *ret;\n"
"}\n"
"template<class T>\n"
"inline std::shared_ptr<T>* cloneReference(const std::shared_ptr<T>& cptr)\n"
"{\n"
"#ifdef __LIBRARYINTERFACEGENERATOR_MEMORY_POOL__\n"
"    auto* ret = MemoryPool::allocate<std::shared_ptr<T>>();\n"
"    *ret = cptr;\n"
"#else\n"
"    auto* ret = new shared_ptr<T>(cptr);\n"
"#endif\n"
"    return ret;\n"
"}\n"
"inline void addReferenceReleaser(void* releaser)\n"
"{\n"
"	auto* param = reinterpret_cast<std::function<void()>*>(releaser);\n"
"	MemoryPool::addReleaser(*param);\n"
"}\n"
"\n"
"\n"
"template<class ENUM>\n"
"inline int32_t createInterfaceEnum(ENUM value)\n"
"{\n"
"	return static_cast<int32_t>(value);\n"
"}\n"
"template<class CLASS>\n"
"inline void* createInterfaceObject(const std::shared_ptr<CLASS>& value)\n"
"{\n"
"	return (void*)cloneReference<CLASS>(value);\n"
"}\n"
"template<class ENUM>\n"
"inline std::vector<int32_t> createInterfaceEnumArray(const std::vector<ENUM>& value)\n"
"{\n"
"	std::vector<int32_t> ret;\n"
"	for (auto& element : value)\n"
"	{\n"
"		auto ielement = createInterfaceEnum(element);\n"
"		ret.push_back(ielement);\n"
"	}\n"
"	return ret;\n"
"}\n"
"template<class ENUM>\n"
"inline std::vector<int32_t> createInterfaceEnumVector(const std::vector<ENUM>& value)\n"
"{\n"
"	std::vector<int32_t> ret;\n"
"	for (auto& element : value)\n"
"	{\n"
"		auto ielement = createInterfaceEnum(element);\n"
"		ret.push_back(ielement);\n"
"	}\n"
"	return ret;\n"
"}\n"
"template<class CLASS>\n"
"inline std::vector<void*> createInterfaceObjectArray(const std::vector<std::shared_ptr<CLASS>>& value)\n"
"{\n"
"	std::vector<void*> ret;\n"
"	for (auto& element : value)\n"
"	{\n"
"		auto ielement = createInterfaceObject(element);\n"
"		ret.push_back(ielement);\n"
"	}\n"
"	return ret;\n"
"}\n"
"template<class CLASS>\n"
"inline std::vector<void*> createInterfaceObjectVector(const std::vector<std::shared_ptr<CLASS>>& value)\n"
"{\n"
"	std::vector<void*> ret;\n"
"	for (auto& element : value)\n"
"	{\n"
"		auto ielement = createInterfaceObject(element);\n"
"		ret.push_back(ielement);\n"
"	}\n"
"	return ret;\n"
"}\n"
"\n"
"template<class ENUM>\n"
"inline ENUM createNativeEnum(int32_t value)\n"
"{\n"
"	return static_cast<ENUM>(value);\n"
"}\n"
"\n"
"template<class CLASS>\n"
"inline std::shared_ptr<CLASS> createNativeObject(const void*& value)\n"
"{\n"
"	return getReference<CLASS>((void *)value);\n"
"}\n"
"\n"
"template<class ENUM>\n"
"inline std::vector<ENUM> createNativeEnumArray(const std::vector<int32_t>& value)\n"
"{\n"
"	std::vector<ENUM> ret;\n"
"	for (auto& element : value)\n"
"	{\n"
"		auto ielement = convertNativeEnum<ENUM>(element);\n"
"		ret.push_back(ielement);\n"
"	}\n"
"	return ret;\n"
"}\n"
"template<class ENUM>\n"
"std::vector<ENUM> createNativeEnumVector(const std::vector<int32_t>& value)\n"
"{\n"
"	std::vector<ENUM> ret;\n"
"	for (auto& element : value)\n"
"	{\n"
"		auto ielement = convertNativeEnum<ENUM>(element);\n"
"		ret.push_back(ielement);\n"
"	}\n"
"	return ret;\n"
"}\n"
"template<class CLASS>\n"
"std::vector<CLASS> createNativeObjectArray(const std::vector<void *>& value)\n"
"{\n"
"	std::vector<CLASS> ret;\n"
"	for (auto& element : value)\n"
"	{\n"
"		auto* ielement = createNativeObject<CLASS>(element);\n"
"		ret.push_back(ielement);\n"
"	}\n"
"	return ret;\n"
"}\n"
"template<class CLASS>\n"
"std::vector<std::shared_ptr<CLASS>> createNativeObjectVector(const std::vector<void*>& value)\n"
"{\n"
"	std::vector<std::shared_ptr<CLASS>> ret;\n"
"	for (auto& element : value)\n"
"	{\n"
"		auto ielement = createNativeObject<CLASS>((const void*&)element);\n"
"		ret.push_back(ielement);\n"
"	}\n"
"	return ret;\n"
"}\n"
"\n"
"template<class ENUM>\n"
"void copyEnum(const ENUM src, int32_t& dest)\n"
"{\n"
"	dest = static_cast<int32_t>(src);\n"
"}\n"
"template<class CLASS>\n"
"void copyObject(const std::shared_ptr<CLASS>& src, void*& dest)\n"
"{\n"
"	dest = (void*)cloneReference<CLASS>(src);\n"
"}\n"
"\n"
"template<class ENUM>\n"
"void copyEnumArray(const std::vector<ENUM>& src, std::vector<int32_t>& dest)\n"
"{\n"
"	dest.clear();\n"
"	for (auto& element : src)\n"
"	{\n"
"		auto ielement = createInterfaceEnum(element);\n"
"		dest.push_back(ielement);\n"
"	}\n"
"}\n"
"\n"
"template<class ENUM>\n"
"void copyEnumVector(const std::vector<ENUM>& src, std::vector<int32_t>& dest)\n"
"{\n"
"	dest.clear();\n"
"	for (auto& element : src)\n"
"	{\n"
"		auto ielement = createInterfaceEnum(element);\n"
"		dest.push_back(ielement);\n"
"	}\n"
"}\n"
"\n"
"template<class CLASS>\n"
"inline void copyObjectArray(const std::vector<CLASS>& src, std::vector<void*>& dest)\n"
"{\n"
"	dest.clear();\n"
"	for (auto& element : src)\n"
"	{\n"
"		auto* ielement = createInterfaceObject(element);\n"
"		dest.push_back(ielement);\n"
"	}\n"
"}\n"
"template<class CLASS>\n"
"inline std::vector<void*> copyObjectVector(const std::vector<CLASS>& src, std::vector<void*>& dest)\n"
"{\n"
"	dest.clear();\n"
"	for (auto& element : src)\n"
"	{\n"
"		auto* ielement = createInterfaceObject(element);\n"
"		dest.push_back(ielement);\n"
"	}\n"
"}\n";
#endif //__BN3MONKEY_LIBRARY_INTERFACE_GENERATOR_NATIVEINTERFACECONVERTER_CPP__
