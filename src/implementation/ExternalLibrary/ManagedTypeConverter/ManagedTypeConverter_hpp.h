#if !defined(__BN3MONKEY_LIBRARY_INTERFACE_GENERATOR_MANAGEDTYPECONVERTER_HPP__)
#define __BN3MONKEY_LIBRARY_INTERFACE_GENERATOR_MANAGEDTYPECONVERTER_HPP__
static constexpr char* MANAGEDTYPECONVERTER_HPP = 
"#ifndef __BN3MONKEY_MANAGED_TYPE_CONVERTER__\n"
"#define __BN3MONKEY_MANAGED_TYPE_CONVERTER__\n"
"\n"
"#include <memory>\n"
"#include <vector>\n"
"#include <functional>\n"
"#include <string>\n"
"#include <algorithm>\n"
"#include <iterator>\n"
"#include <type_traits>\n"
"#include <array>\n"
"\n"
"#include \"../MemoryPool/MemoryPool.hpp\"\n"
"\n"
"namespace Bn3Monkey\n"
"{\n"
"\tclass ManagedTypeConverter\n"
"\t{\n"
"\tpublic:\n"
"\t\tstatic bool initialize();\n"
"\t\tstatic void release();\n"
"\t\tstatic bool isInitialized();\n"
"\t\tstatic void addReleaser(std::function<void()> releaser);\n"
"\n"
"\t\tinline static Bn3Monkey::Bn3Tag handleTag() {\n"
"\t\t\tstatic int num{ 0 };\n"
"\t\t\tchar tag[32]{ 0 };\n"
"\t\t\tsprintf(tag, \"managedhandle_%d\", num++);\n"
"\t\t\treturn Bn3Monkey::Bn3Tag(tag);\n"
"\t\t}\n"
"\t\tinline static Bn3Monkey::Bn3Tag objectTag() {\n"
"\t\t\tstatic int num{ 0 };\n"
"\t\t\tchar tag[32]{ 0 };\n"
"\t\t\tsprintf(tag, \"managedobject_%d\", num++);\n"
"\t\t\treturn Bn3Monkey::Bn3Tag(tag);\n"
"\n"
"\t\t}\n"
"\t};\n"
"\n"
"\tstruct MVoid : ManagedTypeConverter\n"
"\t{\n"
"\t\tusing NativeType = void;\n"
"\t\tusing ManagedType = void;\n"
"\t};\n"
"\n"
"\tstruct MBool : ManagedTypeConverter\n"
"\t{\n"
"\t\tusing NativeType = bool;\n"
"\t\tusing ManagedType = bool;\n"
"\n"
"\t\tNativeType toNativeType(const ManagedType& value) {\n"
"\t\t\treturn static_cast<NativeType>(value);\n"
"\t\t}\n"
"\t\tManagedType toManagedType(const NativeType& value) {\n"
"\t\t\treturn static_cast<ManagedType>(value);\n"
"\t\t}\n"
"\t};\n"
"\n"
"\tstruct MInt8 : ManagedTypeConverter\n"
"\t{\n"
"\t\tusing NativeType = int8_t;\n"
"\t\tusing ManagedType = int8_t;\n"
"\n"
"\t\tNativeType toNativeType(const ManagedType& value) {\n"
"\t\t\treturn static_cast<NativeType>(value);\n"
"\t\t}\n"
"\t\tManagedType toManagedType(const NativeType& value) {\n"
"\t\t\treturn static_cast<ManagedType>(value);\n"
"\t\t}\n"
"\t};\n"
"\n"
"\tstruct MInt16 : ManagedTypeConverter\n"
"\t{\n"
"\t\tusing NativeType = int16_t;\n"
"\t\tusing ManagedType = int16_t;\n"
"\n"
"\t\tNativeType toNativeType(const ManagedType& value) {\n"
"\t\t\treturn static_cast<NativeType>(value);\n"
"\t\t}\n"
"\t\tManagedType toManagedType(const NativeType& value) {\n"
"\t\t\treturn static_cast<ManagedType>(value);\n"
"\t\t}\n"
"\t};\n"
"\n"
"\tstruct MInt32 : ManagedTypeConverter\n"
"\t{\n"
"\t\tusing NativeType = int32_t;\n"
"\t\tusing ManagedType = int32_t;\n"
"\n"
"\t\tNativeType toNativeType(const ManagedType& value) {\n"
"\t\t\treturn static_cast<NativeType>(value);\n"
"\t\t}\n"
"\t\tManagedType toManagedType(const NativeType& value) {\n"
"\t\t\treturn static_cast<ManagedType>(value);\n"
"\t\t}\n"
"\t};\n"
"\n"
"\tstruct MInt64 : ManagedTypeConverter\n"
"\t{\n"
"\t\tusing NativeType = int64_t;\n"
"\t\tusing ManagedType = int64_t;\n"
"\n"
"\t\tNativeType toNativeType(const ManagedType& value) {\n"
"\t\t\treturn static_cast<NativeType>(value);\n"
"\t\t}\n"
"\t\tManagedType toManagedType(const NativeType& value) {\n"
"\t\t\treturn static_cast<ManagedType>(value);\n"
"\t\t}\n"
"\t};\n"
"\n"
"\tstruct MFloat : ManagedTypeConverter\n"
"\t{\n"
"\t\tusing NativeType = float;\n"
"\t\tusing ManagedType = float;\n"
"\n"
"\t\tNativeType toNativeType(const ManagedType& value) {\n"
"\t\t\treturn static_cast<NativeType>(value);\n"
"\t\t}\n"
"\t\tManagedType toManagedType(const NativeType& value) {\n"
"\t\t\treturn static_cast<ManagedType>(value);\n"
"\t\t}\n"
"\t};\n"
"\n"
"\tstruct MDouble : ManagedTypeConverter\n"
"\t{\n"
"\t\tusing NativeType = double;\n"
"\t\tusing ManagedType = double;\n"
"\n"
"\t\tNativeType toNativeType(const ManagedType& value) {\n"
"\t\t\treturn static_cast<NativeType>(value);\n"
"\t\t}\n"
"\t\tManagedType toManagedType(const NativeType& value) {\n"
"\t\t\treturn static_cast<ManagedType>(value);\n"
"\t\t}\n"
"\t};\n"
"\n"
"\tstruct MString : ManagedTypeConverter\n"
"\t{\n"
"\t\tusing NativeType = std::string;\n"
"\t\tusing ManagedType = std::string;\n"
"\n"
"\t\tNativeType toNativeType(const ManagedType& value) {\n"
"\t\t\treturn static_cast<NativeType>(value);\n"
"\t\t}\n"
"\t\tManagedType toManagedType(const NativeType& value) {\n"
"\t\t\treturn static_cast<ManagedType>(value);\n"
"\t\t}\n"
"\t};\n"
"\n"
"\t// \n"
"\ttemplate<typename _NativeEnum>\n"
"\tstruct MEnum : ManagedTypeConverter\n"
"\t{\n"
"\t\tstatic_assert(std::is_enum_v<_NativeEnum>, \"MEnum can receive only Enum as a template argument.\");\n"
"\n"
"\t\tusing NativeType = _NativeEnum;\n"
"\t\tusing ManagedType = int32_t;\n"
"\n"
"\t\tNativeType toNativeType(const ManagedType& value) {\n"
"\t\t\treturn static_cast<NativeType>(value);\n"
"\t\t}\n"
"\t\tManagedType toManagedType(const NativeType& value) {\n"
"\t\t\treturn static_cast<int32_t>(value);\n"
"\t\t}\n"
"\t};\n"
"\n"
"\ttemplate<typename _NativeObject>\n"
"\tstruct MObject : ManagedTypeConverter\n"
"\t{\n"
"\t\tstatic_assert(std::is_class_v<_NativeObject>, \"MObject can receive only object as a template argument.\");\n"
"\n"
"\t\tusing NativeObject = _NativeObject;\n"
"\t\tusing NativeType = std::shared_ptr<NativeObject>;\n"
"\t\tusing ManagedType = void*;\n"
"\n"
"\t\tNativeType toNativeType(const ManagedType& value) {\n"
"\t\t\tNativeType* ref = reinterpret_cast<NativeType*>(value);\n"
"\t\t\treturn *ref;\n"
"\t\t}\n"
"\t\tManagedType toManagedType(const NativeType& value) {\n"
"\t\t\treturn clone(value);\n"
"\t\t}\n"
"\n"
"\t\ttemplate<class... Args>\n"
"\t\tManagedType construct(Args... args)\n"
"\t\t{\n"
"\t\t\tNativeType* ret = createManagedHandle();\n"
"\n"
"#ifdef __BN3MONKEY_MEMORY_POOL__\n"
"\t\t\t* ret = NativeType(Bn3Monkey::Bn3MemoryPool::construct<NativeObject>(ManagedTypeConverter::objectTag(), std::forward<Args>(args)...), [](NativeObject* p) {\n"
"\t\t\t\tBn3Monkey::Bn3MemoryPool::destroy<NativeObject>(p);\n"
"\t\t\t\t});\n"
"#else\n"
"\t\t\t*ret = new NativeObject(args...);\n"
"#endif\n"
"\t\t\treturn reinterpret_cast<ManagedType>(ret);\n"
"\t\t}\n"
"\n"
"\t\tManagedType clone(const NativeType& src)\n"
"\t\t{\n"
"\t\t\tNativeType* ret = createManagedHandle();\n"
"\t\t\t*ret = src;\n"
"\t\t\treturn reinterpret_cast<ManagedType>(ret);\n"
"\t\t}\n"
"\n"
"\t\tvoid release(const ManagedType& ref)\n"
"\t\t{\n"
"\t\t\tNativeType* ret = reinterpret_cast<NativeType*>(ref);\n"
"#ifdef __BN3MONKEY_MEMORY_POOL__\n"
"\t\t\tBn3Monkey::Bn3MemoryPool::destroy(ret);\n"
"#else\n"
"\t\t\tdelete ret;\n"
"#endif\n"
"\t\t}\n"
"\n"
"\n"
"\tprivate:\n"
"\n"
"\t\tNativeType* createManagedHandle()\n"
"\t\t{\n"
"#ifdef __BN3MONKEY_MEMORY_POOL__\n"
"\t\t\treturn Bn3Monkey::Bn3MemoryPool::construct<NativeType>(ManagedTypeConverter::handleTag());\n"
"#else\n"
"\t\t\treturn new NativeObject();\n"
"#endif\n"
"\t\t}\n"
"\t};\n"
"\n"
"\ttemplate<typename ManagedReturnTypeConverter, typename... ManagedArgTypeConverter>\n"
"\tstruct MCallback : ManagedTypeConverter\n"
"\t{\n"
"\t\tusing NativeType = std::function<typename ManagedReturnTypeConverter::NativeType(typename ManagedArgTypeConverter::NativeType...)>;\n"
"\t\tusing ManagedType = std::function<typename ManagedReturnTypeConverter::ManagedType(typename ManagedArgTypeConverter::ManagedType...)>;\n"
"\n"
"\t\tNativeType toNativeType(const ManagedType& value)\n"
"\t\t{\n"
"\t\t\treturn [value](typename ManagedArgTypeConverter::NativeType... args)\n"
"\t\t\t{\n"
"\t\t\t\tauto params = createArgTypes<ManagedArgTypeConverter...>(args...);\n"
"\t\t\t\t\n"
"\t\t\t\tif constexpr (std::is_same_v<MVoid, ManagedReturnTypeConverter>)\n"
"\t\t\t\t{\n"
"\t\t\t\t\tapply(value, params);\n"
"\t\t\t\t}\n"
"\t\t\t\telse\n"
"\t\t\t\t{\n"
"\t\t\t\t\tauto ret = apply(value, params);\n"
"\t\t\t\t\treturn ManagedReturnTypeConverter().toNativeType(ret);\n"
"\t\t\t\t}\n"
"\t\t\t};\n"
"\t\t}\n"
"\n"
"\tprivate:\n"
"\t\ttemplate <class... ManagedTypeConverters>\n"
"\t\tstatic inline std::tuple<typename ManagedTypeConverters::ManagedType...> createArgTypes(typename ManagedTypeConverters::NativeType... args)\n"
"\t\t{\n"
"\t\t\treturn std::make_tuple(ManagedTypeConverters().toManagedType(args)...);\n"
"\t\t}\n"
"\n"
"\t\ttemplate <typename Function, typename Tuple, size_t... Indices>\n"
"\t\tstatic inline constexpr decltype(auto) apply_impl(Function&& func, Tuple&& args, std::index_sequence<Indices...>)\n"
"\t\t{\n"
"\t\t\treturn std::forward<Function>(func)(std::get<Indices>(std::forward<Tuple>(args))...);\n"
"\t\t}\n"
"\n"
"\t\t// Function to apply a function to the elements of a tuple\n"
"\t\ttemplate <typename Function, typename Tuple>\n"
"\t\tstatic inline auto apply(Function&& func, Tuple&& args)\n"
"\t\t{\n"
"\t\t\tconstexpr size_t Size = std::tuple_size<std::decay_t<Tuple>>::value;\n"
"\t\t\treturn apply_impl(std::forward<Function>(func), std::forward<Tuple>(args), std::make_index_sequence<Size>());\n"
"\t\t}\n"
"\n"
"\t};\n"
"\n"
"\ttemplate<class TypeConverter, size_t size, typename std::enable_if_t<std::is_base_of_v<ManagedTypeConverter, TypeConverter>>* = nullptr>\n"
"\tstruct MArray\n"
"\t{\n"
"\t\tusing NativeType = std::array<typename TypeConverter::NativeType, size>;\n"
"\t\tusing ManagedType = std::array<typename TypeConverter::ManagedType, size>;\n"
"\n"
"\t\tNativeType toNativeType(const ManagedType& values)\n"
"\t\t{\n"
"\t\t\tNativeType ret;\n"
"\t\t\tfor (size_t i = 0; i < size; i++)\n"
"\t\t\t{\n"
"\t\t\t\tauto& value = values[i];\n"
"\t\t\t\tauto element = TypeConverter().toNativeType(value);\n"
"\t\t\t\tret[i] = element;\n"
"\t\t\t}\n"
"\t\t\treturn ret;\n"
"\t\t}\n"
"\n"
"\t\tManagedType toManagedType(const NativeType& values)\n"
"\t\t{\n"
"\t\t\tManagedType ret;\n"
"\t\t\tfor (size_t i = 0; i < size; i++)\n"
"\t\t\t{\n"
"\t\t\t\tauto& value = values[i];\n"
"\t\t\t\tauto element = TypeConverter().toManagedType(value);\n"
"\t\t\t\tret[i] = element;\n"
"\t\t\t}\n"
"\t\t\treturn ret;\n"
"\t\t}\n"
"\n"
"\t\tvoid copy(const NativeType& src, ManagedType& dest)\n"
"\t\t{\n"
"\t\t\tfor (size_t i = 0; i < size; i++)\n"
"\t\t\t{\n"
"\t\t\t\tauto& value = src[i];\n"
"\t\t\t\tauto element = TypeConverter().toManagedType(value);\n"
"\t\t\t\tdest[i] = element;\n"
"\t\t\t}\n"
"\t\t}\n"
"\t};\n"
"\n"
"\ttemplate<class TypeConverter, typename std::enable_if_t<std::is_base_of_v<ManagedTypeConverter, TypeConverter>>* = nullptr>\n"
"\tstruct MVector\n"
"\t{\n"
"\t\tusing NativeType = std::vector<typename TypeConverter::NativeType>;\n"
"\t\tusing ManagedType = std::vector<typename TypeConverter::ManagedType>;\n"
"\n"
"\t\tNativeType toNativeType(const ManagedType& values)\n"
"\t\t{\n"
"\t\t\tNativeType ret;\n"
"\t\t\tret.reserve(values.size());\n"
"\t\t\tfor (auto& value : values)\n"
"\t\t\t{\n"
"\t\t\t\tauto element = TypeConverter().toNativeType(value);\n"
"\t\t\t\tret.push_back(element);\n"
"\t\t\t}\n"
"\t\t\treturn ret;\n"
"\t\t}\n"
"\n"
"\t\tManagedType toManagedType(const NativeType& values)\n"
"\t\t{\n"
"\t\t\tManagedType ret;\n"
"\t\t\tret.reserve(values.size());\n"
"\t\t\tfor (auto& value : values)\n"
"\t\t\t{\n"
"\t\t\t\tauto element = TypeConverter().toManagedType(value);\n"
"\t\t\t\tret.push_back(element);\n"
"\t\t\t}\n"
"\t\t\treturn ret;\n"
"\t\t}\n"
"\n"
"\t\tvoid copy(const NativeType& src, ManagedType& dest)\n"
"\t\t{\n"
"\t\t\tdest.clear();\n"
"\t\t\tdest.reserve(src.size());\n"
"\t\t\tfor (auto& value : src)\n"
"\t\t\t{\n"
"\t\t\t\tauto element = TypeConverter().toManagedType(value);\n"
"\t\t\t\tdest.push_back(element);\n"
"\t\t\t}\n"
"\t\t}\n"
"\t};\n"
"}\n"
"\n"
"#endif\n";
#endif //__BN3MONKEY_LIBRARY_INTERFACE_GENERATOR_MANAGEDTYPECONVERTER_HPP__
